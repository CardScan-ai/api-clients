{{#withSeparateModelsAndApi}}
/* tslint:disable */
/* eslint-disable */
{{>licenseInfo}}

import type { Configuration } from '{{apiRelativeToRoot}}configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import * as WebSocket from "ws";
import { XMLParser } from "fast-xml-parser";
import { Stream } from "stream";
import * as FormData from "form-data";
import globalAxios from 'axios';
import {
  CardState,
  CardWebsocketEvent,
  CreateCardRequestBacksideScanningEnum,
  EligibilityInfo,
  EligibilityWebsocketEvent,
  EligibilityState,
  UploadParameters,
  CardWebsocketEventTypeEnum,
} from "../models";
{{#withNodeImports}}
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
{{#multipartFormData}}
import FormData from 'form-data'
{{/multipartFormData}}
{{/withNodeImports}}
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '{{apiRelativeToRoot}}common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '{{apiRelativeToRoot}}base';
{{#imports}}
// @ts-ignore
import { {{classname}} } from '{{apiRelativeToRoot}}{{tsModelPackage}}';
{{/imports}}
{{/withSeparateModelsAndApi}}
{{^withSeparateModelsAndApi}}
{{/withSeparateModelsAndApi}}
{{#operations}}
/**
 * {{classname}} - axios parameter creator{{#description}}
 * {{&description}}{{/description}}
 * @export
 */
export const {{classname}}AxiosParamCreator = function (configuration?: Configuration) {
    return {
    {{#operation}}
        /**
         * {{&notes}}
         {{#summary}}
         * @summary {{&summary}}
         {{/summary}}
         {{#allParams}}
         * @param {{=<% %>=}}{<%#isEnum%><%&datatypeWithEnum%><%/isEnum%><%^isEnum%><%&dataType%><%#isNullable%> | null<%/isNullable%><%/isEnum%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
         {{/allParams}}
         * @param {*} [options] Override http request option.{{#isDeprecated}}
         * @deprecated{{/isDeprecated}}
         * @throws {RequiredError}
         */
        {{nickname}}: async ({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}, {{/allParams}}options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
    {{#allParams}}
    {{#required}}
            // verify required parameter '{{paramName}}' is not null or undefined
            assertParamExists('{{nickname}}', '{{paramName}}', {{paramName}})
    {{/required}}
    {{/allParams}}
            const localVarPath = `{{{path}}}`{{#pathParams}}
                .replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}}))){{/pathParams}};
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: '{{httpMethod}}', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;{{#vendorExtensions}}{{#hasFormParams}}
            const localVarFormParams = new {{^multipartFormData}}URLSearchParams(){{/multipartFormData}}{{#multipartFormData}}((configuration && configuration.formDataCtor) || FormData)(){{/multipartFormData}};{{/hasFormParams}}{{/vendorExtensions}}

    {{#authMethods}}
            // authentication {{name}} required
            {{#isApiKey}}
            {{#isKeyInHeader}}
            await setApiKeyToObject(localVarHeaderParameter, "{{keyParamName}}", configuration)
            {{/isKeyInHeader}}
            {{#isKeyInQuery}}
            await setApiKeyToObject(localVarQueryParameter, "{{keyParamName}}", configuration)
            {{/isKeyInQuery}}
            {{/isApiKey}}
            {{#isBasicBasic}}
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            {{/isBasicBasic}}
            {{#isBasicBearer}}
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            {{/isBasicBearer}}
            {{#isOAuth}}
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}], configuration)
            {{/isOAuth}}

    {{/authMethods}}
    {{#queryParams}}
            {{#isArray}}
            if ({{paramName}}) {
            {{#isCollectionFormatMulti}}
                {{#uniqueItems}}
                localVarQueryParameter['{{baseName}}'] = Array.from({{paramName}});
                {{/uniqueItems}}
                {{^uniqueItems}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}};
                {{/uniqueItems}}
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
                {{#uniqueItems}}
                localVarQueryParameter['{{baseName}}'] = Array.from({{paramName}}).join(COLLECTION_FORMATS.{{collectionFormat}});
                {{/uniqueItems}}
                {{^uniqueItems}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}}.join(COLLECTION_FORMATS.{{collectionFormat}});
                {{/uniqueItems}}
            {{/isCollectionFormatMulti}}
            }
            {{/isArray}}
            {{^isArray}}
            if ({{paramName}} !== undefined) {
                {{#isDateTime}}
                localVarQueryParameter['{{baseName}}'] = ({{paramName}} as any instanceof Date) ?
                    ({{paramName}} as any).toISOString() :
                    {{paramName}};
                {{/isDateTime}}
                {{^isDateTime}}
                {{#isDate}}
                localVarQueryParameter['{{baseName}}'] = ({{paramName}} as any instanceof Date) ?
                    ({{paramName}} as any).toISOString().substring(0,10) :
                    {{paramName}};
                {{/isDate}}
                {{^isDate}}
                {{#isExplode}}
                {{#isPrimitiveType}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}};
                {{/isPrimitiveType}}
                {{^isPrimitiveType}}
                {{^isEnumRef}}
                {{^isEnum}}
                for (const [key, value] of Object.entries({{paramName}})) {
                    localVarQueryParameter[key] = value;
                }
                {{/isEnum}}
                {{/isEnumRef}}
                {{#isEnum}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}};
                {{/isEnum}}
                {{#isEnumRef}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}};
                {{/isEnumRef}}
                {{/isPrimitiveType}}
                {{/isExplode}}
                {{^isExplode}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}};
                {{/isExplode}}
                {{/isDate}}
                {{/isDateTime}}
            }
            {{/isArray}}

    {{/queryParams}}
    {{#headerParams}}
            {{#isArray}}
            if ({{paramName}}) {
                {{#uniqueItems}}
                let mapped = Array.from({{paramName}}).map(value => (<any>"{{{dataType}}}" !== "Set<string>") ? JSON.stringify(value) : (value || ""));
                {{/uniqueItems}}
                {{^uniqueItems}}
                let mapped = {{paramName}}.map(value => (<any>"{{{dataType}}}" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                {{/uniqueItems}}
                localVarHeaderParameter['{{baseName}}'] = mapped.join(COLLECTION_FORMATS["{{collectionFormat}}"]);
            }
            {{/isArray}}
            {{^isArray}}
            {{! `val == null` covers for both `null` and `undefined`}}
            if ({{paramName}} != null) {
                {{#isString}}
                localVarHeaderParameter['{{baseName}}'] = String({{paramName}});
                {{/isString}}
                {{^isString}}
                {{! isString is falsy also for $ref that defines a string or enum type}}
                localVarHeaderParameter['{{baseName}}'] = typeof {{paramName}} === 'string'
                    ? {{paramName}}
                    : JSON.stringify({{paramName}});
                {{/isString}}
            }
            {{/isArray}}

    {{/headerParams}}
    {{#vendorExtensions}}
    {{#formParams}}
            {{#isArray}}
            if ({{paramName}}) {
            {{#isCollectionFormatMulti}}
                {{paramName}}.forEach((element) => {
                    localVarFormParams.{{#multipartFormData}}append{{/multipartFormData}}{{^multipartFormData}}set{{/multipartFormData}}('{{baseName}}', element as any);
                })
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
                localVarFormParams.{{#multipartFormData}}append{{/multipartFormData}}{{^multipartFormData}}set{{/multipartFormData}}('{{baseName}}', {{paramName}}.join(COLLECTION_FORMATS.{{collectionFormat}}));
            {{/isCollectionFormatMulti}}
            }{{/isArray}}
            {{^isArray}}
            if ({{paramName}} !== undefined) { {{^multipartFormData}}
                localVarFormParams.set('{{baseName}}', {{paramName}} as any);{{/multipartFormData}}{{#multipartFormData}}{{#isPrimitiveType}}
                localVarFormParams.append('{{baseName}}', {{paramName}} as any);{{/isPrimitiveType}}{{^isPrimitiveType}}{{#isEnumRef}}
                localVarFormParams.append('{{baseName}}', {{paramName}} as any);{{/isEnumRef}}{{^isEnumRef}}
                localVarFormParams.append('{{baseName}}', new Blob([JSON.stringify({{paramName}})], { type: "application/json", }));{{/isEnumRef}}{{/isPrimitiveType}}{{/multipartFormData}}
            }{{/isArray}}
    {{/formParams}}{{/vendorExtensions}}
    {{#vendorExtensions}}{{#hasFormParams}}{{^multipartFormData}}
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';{{/multipartFormData}}{{#multipartFormData}}
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';{{/multipartFormData}}
    {{/hasFormParams}}{{/vendorExtensions}}
    {{#bodyParam}}
            {{^consumes}}
            localVarHeaderParameter['Content-Type'] = 'application/json';
            {{/consumes}}
            {{#consumes.0}}
            localVarHeaderParameter['Content-Type'] = '{{{mediaType}}}';
            {{/consumes.0}}

    {{/bodyParam}}
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions,{{#hasFormParams}}{{#multipartFormData}} ...(localVarFormParams as any).getHeaders?.(),{{/multipartFormData}}{{/hasFormParams}} ...options.headers};
    {{#hasFormParams}}
            localVarRequestOptions.data = localVarFormParams{{#vendorExtensions}}{{^multipartFormData}}.toString(){{/multipartFormData}}{{/vendorExtensions}};
    {{/hasFormParams}}
    {{#bodyParam}}
            localVarRequestOptions.data = serializeDataIfNeeded({{paramName}}, localVarRequestOptions, configuration)
    {{/bodyParam}}

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    {{/operation}}
    }
};

/**
 * {{classname}} - functional programming interface{{#description}}
 * {{{.}}}{{/description}}
 * @export
 */
export const {{classname}}Fp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = {{classname}}AxiosParamCreator(configuration)
    return {
    {{#operation}}
        /**
         * {{&notes}}
         {{#summary}}
         * @summary {{&summary}}
         {{/summary}}
         {{#allParams}}
         * @param {{=<% %>=}}{<%#isEnum%><%&datatypeWithEnum%><%/isEnum%><%^isEnum%><%&dataType%><%#isNullable%> | null<%/isNullable%><%/isEnum%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
         {{/allParams}}
         * @param {*} [options] Override http request option.{{#isDeprecated}}
         * @deprecated{{/isDeprecated}}
         * @throws {RequiredError}
         */
        async {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}, {{/allParams}}options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{{{returnType}}}{{^returnType}}void{{/returnType}}>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['{{classname}}.{{nickname}}']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    {{/operation}}
    }
};

/**
 * {{classname}} - factory interface{{#description}}
 * {{&description}}{{/description}}
 * @export
 */
export const {{classname}}Factory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = {{classname}}Fp(configuration)
    return {
    {{#operation}}
        /**
         * {{&notes}}
         {{#summary}}
         * @summary {{&summary}}
         {{/summary}}
        {{#useSingleRequestParameter}}
         {{#allParams.0}}
         * @param {{=<% %>=}}{<%& classname %><%& operationIdCamelCase %>Request}<%={{ }}=%> requestParameters Request parameters.
         {{/allParams.0}}
        {{/useSingleRequestParameter}}
        {{^useSingleRequestParameter}}
         {{#allParams}}
         * @param {{=<% %>=}}{<%#isEnum%><%&datatypeWithEnum%><%/isEnum%><%^isEnum%><%&dataType%><%#isNullable%> | null<%/isNullable%><%/isEnum%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
         {{/allParams}}
        {{/useSingleRequestParameter}}
         * @param {*} [options] Override http request option.{{#isDeprecated}}
         * @deprecated{{/isDeprecated}}
         * @throws {RequiredError}
         */
        {{#useSingleRequestParameter}}
        {{nickname}}({{#allParams.0}}requestParameters: {{classname}}{{operationIdCamelCase}}Request{{^hasRequiredParams}} = {}{{/hasRequiredParams}}, {{/allParams.0}}options?: RawAxiosRequestConfig): AxiosPromise<{{{returnType}}}{{^returnType}}void{{/returnType}}> {
            return localVarFp.{{nickname}}({{#allParams.0}}{{#allParams}}requestParameters.{{paramName}}, {{/allParams}}{{/allParams.0}}options).then((request) => request(axios, basePath));
        },
        {{/useSingleRequestParameter}}
        {{^useSingleRequestParameter}}
        {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}, {{/allParams}}options?: any): AxiosPromise<{{{returnType}}}{{^returnType}}void{{/returnType}}> {
            return localVarFp.{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options).then((request) => request(axios, basePath));
        },
        {{/useSingleRequestParameter}}
    {{/operation}}
    };
};

{{#withInterfaces}}
/**
 * {{classname}} - interface{{#description}}
 * {{&description}}{{/description}}
 * @export
 * @interface {{classname}}
 */
export interface {{classname}}Interface {
{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{=<% %>=}}{<%#isEnum%><%&datatypeWithEnum%><%/isEnum%><%^isEnum%><%&dataType%><%#isNullable%> | null<%/isNullable%><%/isEnum%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
     {{/allParams}}
     * @param {*} [options] Override http request option.{{#isDeprecated}}
     * @deprecated{{/isDeprecated}}
     * @throws {RequiredError}
     * @memberof {{classname}}Interface
     */
    {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}, {{/allParams}}options?: RawAxiosRequestConfig): AxiosPromise<{{{returnType}}}{{^returnType}}void{{/returnType}}>;

{{/operation}}
}

{{/withInterfaces}}
{{#useSingleRequestParameter}}
{{#operation}}
{{#allParams.0}}
/**
 * Request parameters for {{nickname}} operation in {{classname}}.
 * @export
 * @interface {{classname}}{{operationIdCamelCase}}Request
 */
export interface {{classname}}{{operationIdCamelCase}}Request {
    {{#allParams}}
    /**
     * {{description}}
     * @type {{=<% %>=}}{<%&dataType%>}<%={{ }}=%>
     * @memberof {{classname}}{{operationIdCamelCase}}
     */
    readonly {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}
    {{^-last}}

    {{/-last}}
    {{/allParams}}
}

{{/allParams.0}}
{{/operation}}
{{/useSingleRequestParameter}}
/**
 * {{classname}} - object-oriented interface{{#description}}
 * {{{.}}}{{/description}}
 * @export
 * @class {{classname}}
 * @extends {BaseAPI}
 */
{{#withInterfaces}}
export class {{classname}} extends BaseAPI implements {{classname}}Interface {
{{/withInterfaces}}
{{^withInterfaces}}
export class {{classname}} extends BaseAPI {
  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected axios: AxiosInstance = globalAxios,
  ) {
    super(configuration, basePath, axios);
  }

  /**
   * Utility method to create a websocket connection
   * @param cb This callback will be invoked with the websocket object once the connection is established or with an error if the connection fails.
   */
  public withWebsocket = (
    cb: (websocket: WebSocket | null, error: Error | null) => Promise<any>,
  ) => {
    const token = this.configuration.accessToken ?? this.configuration.apiKey;

    const websocket = new WebSocket(
      `${this.configuration.websocketUrl}?token=${token}`,
    );

    this.debug("Connecting to websocket...");

    websocket.on("error", async (err) => {
      this.error(`Websocket error: ${err.message}`);
      await cb(null, err);
    });

    websocket.onopen = async () => {
      try {
        this.debug("Websocket connected. Invoking callback...");
        await cb(websocket, null);
      } catch (e) {
      } finally {
        this.debug("Websocket closing...");
        websocket.close();
      }
    };
  };

  /**
   * @summary Performs a full scan, including both front and back side scans. (This method requires a websocket URL to be set in the configuration.)
   * @param frontImage The front side image to scan. For client side code this can be a File object, for server side code this can be a Blob or a Stream.
   * @param backImage The back side image to scan. For client side code this can be a File object, for server side code this can be a Blob or a Stream.
   * */
  public async fullScan({
    frontImage,
    backImage,
  }: {
    frontImage: File | Blob | Stream;
    backImage?: File | Blob | Stream;
  }) {
    this.info("Starting full scan...");

    if (!this.configuration?.websocketUrl) {
      this.error("Websocket URL not set in configuration.");
      throw new Error("This method cannot be called without a websocket URL.");
    }

    this.debug("Creating card...");
    const card = (
      await this.createCard({
        enable_livescan: false,
        enable_backside_scan: Boolean(backImage),
      })
    ).data;

    this.debug(`Card created successfully: ${JSON.stringify(card)}`);

    return new Promise((resolve, reject) => {
      this.withWebsocket(async (websocket, err) => {
        if (err) {
          return reject(err);
        }

        this.debug("Registering websocket card...");
        websocket.send(
          JSON.stringify({
            action: "register",
            card_id: card.card_id,
          }),
        );
        this.debug("Websocket card registered");

        this.debug("Generating front side upload URL...");
        const frontSideUploadUrlResponse = (
          await this.generateCardUploadUrl(card.card_id, 3600, {
            orientation: ScanOrientation.Front,
          })
        ).data;
        this.debug(
          `Front side upload URL generated successfully, response: ${JSON.stringify(frontSideUploadUrlResponse)}}`,
        );

        const formDataFront = this.cardFormDataFactory(
          frontImage,
          frontSideUploadUrlResponse.upload_parameters,
        );

        try {
          this.debug("Uploading front side image...");
          await this.axios.post(
            frontSideUploadUrlResponse.upload_url,
            formDataFront,
            {
              headers: {
                "Content-Type": "multipart/form-data",
              },
            },
          );
          this.debug("Front side image uploaded successfully");
        } catch (error) {
          this.error(
            `Error uploading front side image. Error: ${error.message}`,
          );

          if (error.response && error.response.data) {
            this.debug("Parsing error response...");
            const parser = new XMLParser();
            const errorResponse = parser.parse(error.response.data);
            const cardError = this.XMLErrorToCardScanError(
              errorResponse.Error,
              error.response.status,
            );
            this.debug(
              `Error response parsed successfully. Parsed error: ${error.response.data}`,
            );
            return reject(cardError);
          } else {
            return reject(error);
          }
        }

        const frontSideRejectionStates: CardState[] = [
          CardState.FrontsideFailed,
          CardState.Error,
        ];

        this.debug("Waiting for front side processing to complete...");
        const frontSideEvent: CardWebsocketEvent = await new Promise(
          (resolve, reject) => {
            websocket.onmessage = (event) => {
              const data: CardWebsocketEvent = JSON.parse(event.data as string);
              this.debug(`Received websocket message: ${event.data}`);

              if (data.type !== CardWebsocketEventTypeEnum.Card) return;

              if (frontSideRejectionStates.includes(data.state)) {
                this.debug(
                  `Received reject state while processing frontside: ${data.state}`,
                );

                return reject(
                  new Error(`Frontside failed: ${data.error?.message}`),
                );
              }

              if (
                data.state === CardState.BacksideProcessing ||
                data.state === CardState.Completed
              ) {
                this.debug("Front side processing completed successfully");
                return resolve(data);
              }
            };
          },
        );

        if (!backImage) {
          this.info("Full scan completed successfully");

          this.debug("Fetching card details...");
          const cardDetails = (await this.getCardById(frontSideEvent.card_id))
            .data;

          return resolve(cardDetails);
        }

        this.debug("Generating back side upload URL...");
        const backSideUploadUrlResponse = (
          await this.generateCardUploadUrl(card.card_id, 3600, {
            orientation: ScanOrientation.Back,
          })
        ).data;

        const formDataBack = this.cardFormDataFactory(
          backImage,
          backSideUploadUrlResponse.upload_parameters,
        );

        try {
          this.debug("Uploading back side image...");
          await this.axios.post(
            backSideUploadUrlResponse.upload_url,
            formDataBack,
            {
              headers: {
                "Content-Type": "multipart/form-data",
              },
            },
          );
        } catch (error) {
          this.error(
            `Error uploading back side image. Error: ${error.message}`,
          );

          if (error.response && error.response.data) {
            this.debug("Parsing error response...");
            const parser = new XMLParser();
            const errorResponse = parser.parse(error.response.data);
            const cardError = this.XMLErrorToCardScanError(
              errorResponse.Error,
              error.response.status,
            );
            this.debug(
              `Error response parsed successfully. Parsed error: ${error.response.data}`,
            );
            return reject(cardError);
          } else {
            return reject(error);
          }
        }

        const backSideRejectionStates: CardState[] = [
          CardState.BacksideFailed,
          CardState.Error,
        ];

        this.debug("Waiting for back side processing to complete...");

        const event: CardWebsocketEvent = await new Promise(
          (resolve, reject) => {
            websocket.onmessage = (event) => {
              const data: CardWebsocketEvent = JSON.parse(event.data as string);
              this.debug(`Received websocket message: ${event.data}`);

              if (data.type !== CardWebsocketEventTypeEnum.Card) return;

              if (backSideRejectionStates.includes(data.state)) {
                this.debug(
                  `Received reject state while processing backside: ${data.state}`,
                );
                return reject(
                  new Error(`Backside failed: ${data.error?.message}`),
                );
              }

              if (data.state === CardState.Completed) {
                this.debug(`Back side processing completed successfully`);
                return resolve(data);
              }
            };
          },
        );

        this.info("Full scan completed successfully");
        this.debug("Fetching card details...");

        const cardDetails = (await this.getCardById(event.card_id)).data;
        resolve(cardDetails);
      });
    });
  }
  
  private cardFormDataFactory(
    file: File | Blob | Stream,
    uploadParameters: UploadParameters,
  ) {
    const formData = new FormData();

    for (const [key, value] of Object.entries(uploadParameters)) {
      formData.append(key, value);
    }

    formData.append("file", file);

    return formData;
  }

  private XMLErrorToCardScanError(
    xmlErrorObj: {
      Message: string;
      Code: string;
    },
    code: number,
  ): ApiErrorResponse {
    return {
      message: xmlErrorObj.Message,
      type: xmlErrorObj.Code,
      code,
    };
  }


  /**
   * @summary Performs an eligibility check for a card. (This method requires a websocket URL to be set in the configuration.)
   * @param cardId The ID of the card
   * @param eligibility The eligibility information to check
   * */
  public async checkEligibility(cardId: string, eligibility: EligibilityInfo) {
    if (!this.configuration?.websocketUrl) {
      this.error("Websocket URL not set in configuration");
      throw new Error("This method cannot be called without a websocket URL.");
    }

    this.info(`Checking eligibility for card: ${cardId}`);

    return new Promise((resolve, reject) => {
      this.withWebsocket(async (websocket, err) => {
        if (err) {
          this.error(`Error connecting to websocket: ${err.message}`);
          return reject(err);
        }

        try {
          this.debug(`Creating eligibility for card: ${cardId}`);

          const response = (
            await this.createEligibility({
              card_id: cardId,
              eligibility,
            })
          ).data;

          this.debug(
            `Eligibility created successfully: ${JSON.stringify(response)}`,
          );
        } catch (e) {
          return reject(e);
        }

        this.debug("Registering card with websocket...");
        websocket.send(
          JSON.stringify({
            action: "register",
            card_id: cardId,
          }),
        );

        this.debug("Card registered with websocket");

        this.debug("Waiting for eligibility check to complete...");
        const event: EligibilityWebsocketEvent = await new Promise(
          (resolve, reject) => {
            websocket.onmessage = (event) => {
              const data: EligibilityWebsocketEvent = JSON.parse(
                event.data as string,
              );
              this.debug(`Received websocket message: ${event.data}`);

              if (data.state === EligibilityState.Completed) {
                this.debug("Received completed state");
                return resolve(data);
              }

              if (data.state === EligibilityState.Error) {
                this.debug("Received error state");
                return reject(
                  new Error(
                    `Eligibility process failed: ${data.error?.message}`,
                  ),
                );
              }
            };
          },
        );

        this.info(`Eligibility check completed successfully`);
        resolve(event);
      });
    });
  }

{{/withInterfaces}}
    {{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#useSingleRequestParameter}}
     {{#allParams.0}}
     * @param {{=<% %>=}}{<%& classname %><%& operationIdCamelCase %>Request}<%={{ }}=%> requestParameters Request parameters.
     {{/allParams.0}}
     {{/useSingleRequestParameter}}
     {{^useSingleRequestParameter}}
     {{#allParams}}
     * @param {{=<% %>=}}{<%#isEnum%><%&datatypeWithEnum%><%/isEnum%><%^isEnum%><%&dataType%><%#isNullable%> | null<%/isNullable%><%/isEnum%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
     {{/allParams}}
     {{/useSingleRequestParameter}}
     * @param {*} [options] Override http request option.{{#isDeprecated}}
     * @deprecated{{/isDeprecated}}
     * @throws {RequiredError}
     * @memberof {{classname}}
     */
    {{#useSingleRequestParameter}}
    public {{nickname}}({{#allParams.0}}requestParameters: {{classname}}{{operationIdCamelCase}}Request{{^hasRequiredParams}} = {}{{/hasRequiredParams}}, {{/allParams.0}}options?: RawAxiosRequestConfig) {
        return {{classname}}Fp(this.configuration).{{nickname}}({{#allParams.0}}{{#allParams}}requestParameters.{{paramName}}, {{/allParams}}{{/allParams.0}}options).then((request) => request(this.axios, this.basePath));
    }
    {{/useSingleRequestParameter}}
    {{^useSingleRequestParameter}}
    public {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}, {{/allParams}}options?: RawAxiosRequestConfig) {
        return {{classname}}Fp(this.configuration).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options).then((request) => request(this.axios, this.basePath));
    }
    {{/useSingleRequestParameter}}
    {{^-last}}

    {{/-last}}
    {{/operation}}
}
{{/operations}}

{{#operations}}
{{#operation}}
{{#allParams}}
{{#isEnum}}
{{#stringEnums}}
/**
  * @export
  * @enum {string}
  */
export enum {{operationIdCamelCase}}{{enumName}} {
{{#allowableValues}}
    {{#enumVars}}
    {{{name}}} = {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
}
{{/stringEnums}}
{{^stringEnums}}
/**
 * @export
 */
export const {{operationIdCamelCase}}{{enumName}} = {
{{#allowableValues}}
    {{#enumVars}}
    {{{name}}}: {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
} as const;
export type {{operationIdCamelCase}}{{enumName}} = typeof {{operationIdCamelCase}}{{enumName}}[keyof typeof {{operationIdCamelCase}}{{enumName}}];
{{/stringEnums}}
{{/isEnum}}
{{/allParams}}
{{/operation}}
{{/operations}}
