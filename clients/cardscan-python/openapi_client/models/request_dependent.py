# coding: utf-8

"""
    CardScan API

    The official documentation for the CardScan API.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
from openapi_client.models.additional_identification import AdditionalIdentification
from openapi_client.models.address import Address
from openapi_client.models.health_care_information import HealthCareInformation

class RequestDependent(BaseModel):
    """
    Loop: 2000D, Notes: Dependent Detail  # noqa: E501
    """
    birth_sequence_number: Optional[constr(strict=True, max_length=9, min_length=0)] = Field(None, alias="birthSequenceNumber", description="Loop: 2100D Segment: INS, Element: INS17, Notes: Birth Sequence Number - must be exactly 9 positive unsigned numeric characters.")
    individual_relationship_code: Optional[StrictStr] = Field(None, alias="individualRelationshipCode", description="Loop: 2100D Segment: INS, Element: INS02, Notes: Allowed Values are: '01' - Spouse, '19' - Child, '34' Other Adult")
    issue_number: Optional[constr(strict=True, max_length=50, min_length=0)] = Field(None, alias="issueNumber", description="Loop: 2100D Segment: REF, Element: REF02, Notes: REF01=IF Issue Number")
    eligibility_category: Optional[constr(strict=True, max_length=50, min_length=0)] = Field(None, alias="eligibilityCategory", description="Loop: 2100D Segment: REF, Element: REF02, Notes: REF01=MRC Eligibility Category")
    member_id: Optional[constr(strict=True, max_length=80, min_length=2)] = Field(None, alias="memberId", description="Loop: 2100C and 2100D, Segment: MN1, Element: NM109, Notes: NM108=MI, memberId 2-80 alphanumeric characters")
    first_name: Optional[constr(strict=True, max_length=35, min_length=0)] = Field(None, alias="firstName", description="Loop: 2100C and 2100D, Segment: MN1, Element: NM104, Notes: firstName 1-35 alphanumeric characters")
    middle_name: Optional[constr(strict=True, max_length=25, min_length=0)] = Field(None, alias="middleName", description="Loop: 2100C and 2100D, Segment: MN1, Element: NM105, Notes: middleName 1-25 alphanumeric characters")
    last_name: Optional[constr(strict=True, max_length=60, min_length=0)] = Field(None, alias="lastName", description="Loop: 2100C and 2100D, Segment: MN1, Element: NM103, Notes: lastName 1-60 alphanumeric characters")
    suffix: Optional[constr(strict=True, max_length=10, min_length=0)] = Field(None, description="Loop: 2100C and 2100D, Segment: MN1, Element: NM107, Notes: lastName 1-10 alphanumeric characters")
    gender: Optional[constr(strict=True, max_length=1, min_length=0)] = Field(None, description="Loop: 2100C and 2100D, Segment: DMG, Element: DMG03, Notes: gender 1 character 'M' or 'F'")
    date_of_birth: Optional[StrictStr] = Field(None, alias="dateOfBirth", description="Loop: 2100C and 2100D, Segment: DMG, Element: DMG02, Notes: date of birth in YYYYMMDD")
    ssn: Optional[constr(strict=True, max_length=50, min_length=0)] = Field(None, description="Loop: 2100C and 2100D, Segment: REF, Element: REF02, Notes: REF01=SY Social Security Number")
    group_number: Optional[constr(strict=True, max_length=50, min_length=0)] = Field(None, alias="groupNumber", description="Loop: 2100C and 2100D, Segment: REF, Element: REF02, Notes: REF01=6P Group Number")
    id_card: Optional[constr(strict=True, max_length=50, min_length=0)] = Field(None, alias="idCard", description="Loop: 2100C and 2100D, Segment: REF, Element: REF02, Notes: REF01=HJ Identity Card Number")
    provider_code: Optional[StrictStr] = Field(None, alias="providerCode", description="Loop: 2100C and 2100D, Segment: PRV, Element: PRV01, Notes: Provider Code, Notes: Allowed Values are: 'AD' Admitting, 'AT' Attending, 'BI' Billing, 'CO' Consulting, 'CV' Covering, 'H' Hospital, 'HH' Home Health Care, 'LA' Laboratory, 'OT' Other Physician, 'P1' Pharmacist, 'P2' Pharmacy, 'PC' Primary Care Physician, 'PE' Performing, 'R' Rural Health Clinic, 'RF' Referring, 'SK' Skilled Nursing Facility, 'SU' Supervising")
    reference_identification_qualifier: Optional[StrictStr] = Field(None, alias="referenceIdentificationQualifier", description="Loop: 2100C and 2100D, Segment: PRV, Element: PRV02, Notes: Allowed Values are: '9K' Servicer, 'D3' National Council for Prescription Drug Programs Pharmacy Number, 'EI' Employer's Identification Number, 'HPI' Centers for Medicare and Medicaid Services National Provider Identifier, 'PXC' Health Care Provider Taxonomy Code, 'SY' Social Security Number, 'TJ' Federal Taxpayer's Identification Number")
    provider_identifier: Optional[constr(strict=True, max_length=50, min_length=0)] = Field(None, alias="providerIdentifier", description="Loop: 2100C and 2100D, Segment: PRV, Element: PRV03, Notes: Provider Identifier")
    beginning_card_issue_date: Optional[StrictStr] = Field(None, alias="beginningCardIssueDate", description="Loop: 2110C and 2110D, Segment: DTP, Element: DTP03, Notes: DTP01=102, DTP02=RD8 Retired")
    end_card_issue_date: Optional[StrictStr] = Field(None, alias="endCardIssueDate", description="Loop: 2110C and 2110D, Segment: DTP, Element: DTP03, Notes: DTP01=102, DTP02=RD8 Retired")
    id_card_issue_date: Optional[StrictStr] = Field(None, alias="idCardIssueDate", description="Loop: 2110C and 2110D, Segment: DTP, Element: DTP03, Notes: DTP01=102, DTP02=D8 Retired")
    plan_issue_date: Optional[StrictStr] = Field(None, alias="planIssueDate", description="Loop: 2110C and 2110D, Segment: DTP, Element: DTP03, Notes: DTP01=291, DTP02=D8 Retired")
    beginning_plan_issue_date: Optional[StrictStr] = Field(None, alias="beginningPlanIssueDate", description="Loop: 2110C and 2110D, Segment: DTP, Element: DTP03, Notes: DTP01=291, DTP02=RD8 Retired")
    end_plan_issue_date: Optional[StrictStr] = Field(None, alias="endPlanIssueDate", description="Loop: 2110C and 2110D, Segment: DTP, Element: DTP03, Notes: DTP01=291, DTP02=RD8 Retired")
    health_care_code_information: Optional[conlist(HealthCareInformation, max_items=8, min_items=0)] = Field(None, alias="healthCareCodeInformation", description="Loop: 2100C and 2100D, Segment: HI, Element: HI01-1 HI01-2, Notes: Health Care Diagnosis")
    address: Optional[Address] = None
    additional_identification: Optional[AdditionalIdentification] = Field(None, alias="additionalIdentification")
    additional_properties: Dict[str, Any] = {}
    __properties = ["birthSequenceNumber", "individualRelationshipCode", "issueNumber", "eligibilityCategory", "memberId", "firstName", "middleName", "lastName", "suffix", "gender", "dateOfBirth", "ssn", "groupNumber", "idCard", "providerCode", "referenceIdentificationQualifier", "providerIdentifier", "beginningCardIssueDate", "endCardIssueDate", "idCardIssueDate", "planIssueDate", "beginningPlanIssueDate", "endPlanIssueDate", "healthCareCodeInformation", "address", "additionalIdentification"]

    @validator('birth_sequence_number')
    def birth_sequence_number_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9]+$", value):
            raise ValueError(r"must validate the regular expression /^[0-9]+$/")
        return value

    @validator('individual_relationship_code')
    def individual_relationship_code_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('01', '19', '34'):
            raise ValueError("must be one of enum values ('01', '19', '34')")
        return value

    @validator('member_id')
    def member_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[A-Za-z0-9-]+$", value):
            raise ValueError(r"must validate the regular expression /^[A-Za-z0-9-]+$/")
        return value

    @validator('gender')
    def gender_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('M', 'F'):
            raise ValueError("must be one of enum values ('M', 'F')")
        return value

    @validator('provider_code')
    def provider_code_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('AD', 'AT', 'BI', 'CO', 'CV', 'H', 'HH', 'LA', 'OT', 'P1', 'P2', 'PC', 'PE', 'R', 'RF', 'SK', 'SU'):
            raise ValueError("must be one of enum values ('AD', 'AT', 'BI', 'CO', 'CV', 'H', 'HH', 'LA', 'OT', 'P1', 'P2', 'PC', 'PE', 'R', 'RF', 'SK', 'SU')")
        return value

    @validator('reference_identification_qualifier')
    def reference_identification_qualifier_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('9K', 'D3', 'EI', 'HPI', 'PXC', 'SY', 'TJ'):
            raise ValueError("must be one of enum values ('9K', 'D3', 'EI', 'HPI', 'PXC', 'SY', 'TJ')")
        return value

    @validator('provider_identifier')
    def provider_identifier_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[A-Za-z0-9]+$", value):
            raise ValueError(r"must validate the regular expression /^[A-Za-z0-9]+$/")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> RequestDependent:
        """Create an instance of RequestDependent from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "additional_properties"
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in health_care_code_information (list)
        _items = []
        if self.health_care_code_information:
            for _item in self.health_care_code_information:
                if _item:
                    _items.append(_item.to_dict())
            _dict['healthCareCodeInformation'] = _items
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict['address'] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of additional_identification
        if self.additional_identification:
            _dict['additionalIdentification'] = self.additional_identification.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> RequestDependent:
        """Create an instance of RequestDependent from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return RequestDependent.parse_obj(obj)

        _obj = RequestDependent.parse_obj({
            "birth_sequence_number": obj.get("birthSequenceNumber"),
            "individual_relationship_code": obj.get("individualRelationshipCode"),
            "issue_number": obj.get("issueNumber"),
            "eligibility_category": obj.get("eligibilityCategory"),
            "member_id": obj.get("memberId"),
            "first_name": obj.get("firstName"),
            "middle_name": obj.get("middleName"),
            "last_name": obj.get("lastName"),
            "suffix": obj.get("suffix"),
            "gender": obj.get("gender"),
            "date_of_birth": obj.get("dateOfBirth"),
            "ssn": obj.get("ssn"),
            "group_number": obj.get("groupNumber"),
            "id_card": obj.get("idCard"),
            "provider_code": obj.get("providerCode"),
            "reference_identification_qualifier": obj.get("referenceIdentificationQualifier"),
            "provider_identifier": obj.get("providerIdentifier"),
            "beginning_card_issue_date": obj.get("beginningCardIssueDate"),
            "end_card_issue_date": obj.get("endCardIssueDate"),
            "id_card_issue_date": obj.get("idCardIssueDate"),
            "plan_issue_date": obj.get("planIssueDate"),
            "beginning_plan_issue_date": obj.get("beginningPlanIssueDate"),
            "end_plan_issue_date": obj.get("endPlanIssueDate"),
            "health_care_code_information": [HealthCareInformation.from_dict(_item) for _item in obj.get("healthCareCodeInformation")] if obj.get("healthCareCodeInformation") is not None else None,
            "address": Address.from_dict(obj.get("address")) if obj.get("address") is not None else None,
            "additional_identification": AdditionalIdentification.from_dict(obj.get("additionalIdentification")) if obj.get("additionalIdentification") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


