# coding: utf-8

"""
    CardScan API

    The official documentation for the CardScan API.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist
from openapi_client.models.benefits_information import BenefitsInformation
from openapi_client.models.eligibility_api_error import EligibilityApiError
from openapi_client.models.meta_data import MetaData
from openapi_client.models.payer import Payer
from openapi_client.models.plan_date_information import PlanDateInformation
from openapi_client.models.plan_information import PlanInformation
from openapi_client.models.plan_status import PlanStatus
from openapi_client.models.response_member import ResponseMember
from openapi_client.models.response_provider import ResponseProvider
from openapi_client.models.subscriber_trace_number import SubscriberTraceNumber

class Response(BaseModel):
    """
    Response
    """
    meta: Optional[MetaData] = None
    control_number: Optional[StrictStr] = Field(None, alias="controlNumber", description="Segment: ISA, Element: ISA13, Notes: Interchange Control Number original request")
    reassociation_key: Optional[StrictStr] = Field(None, alias="reassociationKey", description="Segment: ISA, Element: ISA13, Notes: Interchange Control Number")
    trading_partner_service_id: Optional[StrictStr] = Field(None, alias="tradingPartnerServiceId", description="This is the payorId or Identification Code that was sent in the 270")
    provider: Optional[ResponseProvider] = None
    subscriber: Optional[ResponseMember] = None
    subscriber_trace_numbers: Optional[conlist(SubscriberTraceNumber)] = Field(None, alias="subscriberTraceNumbers", description="Loop: 2100C and 2100D, Segment: TRN, Notes: Subscriber Trace Numbers")
    dependents: Optional[conlist(ResponseMember)] = Field(None, description="Loop: 2100D, Notes: Dependent Details")
    payer: Optional[Payer] = None
    plan_information: Optional[PlanInformation] = Field(None, alias="planInformation")
    plan_date_information: Optional[PlanDateInformation] = Field(None, alias="planDateInformation")
    plan_status: Optional[conlist(PlanStatus)] = Field(None, alias="planStatus", description="Loop: 2110C and 2110D, Segments: EB, Notes: Subscriber/Dependent Eligibility Benefit Information - Deprecated please use benefitsInformation")
    benefits_information: Optional[conlist(BenefitsInformation)] = Field(None, alias="benefitsInformation", description="Loop: 2110C and 2110D, Segments: NM1, PER, PRV, N3, N4, EB, H SD, MSG, LS, LE, REF, DTP, Notes: Subscriber/Dependent Eligibility Benefit Information")
    errors: Optional[conlist(EligibilityApiError)] = None
    status: Optional[StrictStr] = None
    transaction_set_acknowledgement: Optional[StrictStr] = Field(None, alias="transactionSetAcknowledgement")
    implementation_transaction_set_syntax_error: Optional[StrictStr] = Field(None, alias="implementationTransactionSetSyntaxError")
    x12: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties = ["meta", "controlNumber", "reassociationKey", "tradingPartnerServiceId", "provider", "subscriber", "subscriberTraceNumbers", "dependents", "payer", "planInformation", "planDateInformation", "planStatus", "benefitsInformation", "errors", "status", "transactionSetAcknowledgement", "implementationTransactionSetSyntaxError", "x12"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Response:
        """Create an instance of Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "additional_properties"
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of meta
        if self.meta:
            _dict['meta'] = self.meta.to_dict()
        # override the default output from pydantic by calling `to_dict()` of provider
        if self.provider:
            _dict['provider'] = self.provider.to_dict()
        # override the default output from pydantic by calling `to_dict()` of subscriber
        if self.subscriber:
            _dict['subscriber'] = self.subscriber.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in subscriber_trace_numbers (list)
        _items = []
        if self.subscriber_trace_numbers:
            for _item in self.subscriber_trace_numbers:
                if _item:
                    _items.append(_item.to_dict())
            _dict['subscriberTraceNumbers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in dependents (list)
        _items = []
        if self.dependents:
            for _item in self.dependents:
                if _item:
                    _items.append(_item.to_dict())
            _dict['dependents'] = _items
        # override the default output from pydantic by calling `to_dict()` of payer
        if self.payer:
            _dict['payer'] = self.payer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of plan_information
        if self.plan_information:
            _dict['planInformation'] = self.plan_information.to_dict()
        # override the default output from pydantic by calling `to_dict()` of plan_date_information
        if self.plan_date_information:
            _dict['planDateInformation'] = self.plan_date_information.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in plan_status (list)
        _items = []
        if self.plan_status:
            for _item in self.plan_status:
                if _item:
                    _items.append(_item.to_dict())
            _dict['planStatus'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in benefits_information (list)
        _items = []
        if self.benefits_information:
            for _item in self.benefits_information:
                if _item:
                    _items.append(_item.to_dict())
            _dict['benefitsInformation'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in errors (list)
        _items = []
        if self.errors:
            for _item in self.errors:
                if _item:
                    _items.append(_item.to_dict())
            _dict['errors'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Response:
        """Create an instance of Response from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Response.parse_obj(obj)

        _obj = Response.parse_obj({
            "meta": MetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
            "control_number": obj.get("controlNumber"),
            "reassociation_key": obj.get("reassociationKey"),
            "trading_partner_service_id": obj.get("tradingPartnerServiceId"),
            "provider": ResponseProvider.from_dict(obj.get("provider")) if obj.get("provider") is not None else None,
            "subscriber": ResponseMember.from_dict(obj.get("subscriber")) if obj.get("subscriber") is not None else None,
            "subscriber_trace_numbers": [SubscriberTraceNumber.from_dict(_item) for _item in obj.get("subscriberTraceNumbers")] if obj.get("subscriberTraceNumbers") is not None else None,
            "dependents": [ResponseMember.from_dict(_item) for _item in obj.get("dependents")] if obj.get("dependents") is not None else None,
            "payer": Payer.from_dict(obj.get("payer")) if obj.get("payer") is not None else None,
            "plan_information": PlanInformation.from_dict(obj.get("planInformation")) if obj.get("planInformation") is not None else None,
            "plan_date_information": PlanDateInformation.from_dict(obj.get("planDateInformation")) if obj.get("planDateInformation") is not None else None,
            "plan_status": [PlanStatus.from_dict(_item) for _item in obj.get("planStatus")] if obj.get("planStatus") is not None else None,
            "benefits_information": [BenefitsInformation.from_dict(_item) for _item in obj.get("benefitsInformation")] if obj.get("benefitsInformation") is not None else None,
            "errors": [EligibilityApiError.from_dict(_item) for _item in obj.get("errors")] if obj.get("errors") is not None else None,
            "status": obj.get("status"),
            "transaction_set_acknowledgement": obj.get("transactionSetAcknowledgement"),
            "implementation_transaction_set_syntax_error": obj.get("implementationTransactionSetSyntaxError"),
            "x12": obj.get("x12")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


