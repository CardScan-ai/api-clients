# coding: utf-8

"""
    CardScan API

    The official documentation for the CardScan API.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, Optional
from pydantic import BaseModel, Field, StrictStr, constr, validator

class Provider(BaseModel):
    """
    Loop: 2100B, Segment: NM1, Notes: Information Receiver  # noqa: E501
    """
    organization_name: Optional[constr(strict=True, max_length=60, min_length=0)] = Field(None, alias="organizationName", description="Loop: 2100B Segment: MN1, Element: NM103, Notes: NM101=PR when providerType='payer' && payerId is present otherwise 1P for Provider, NM102=2 Non-Person Entity, organizationName 1-60 alphanumeric characters")
    first_name: Optional[constr(strict=True, max_length=35, min_length=0)] = Field(None, alias="firstName", description="Loop: 2100B Segment: MN1, Element: NM104, Notes: NM101=PR when providerType='payer' && payerId is present otherwise 1P for Provider, NM102=1 Person, firstName 1-35 alphanumeric characters")
    last_name: Optional[constr(strict=True, max_length=60, min_length=0)] = Field(None, alias="lastName", description="Loop: 2100B Segment: MN1, Element: NM103, Notes: NM101=PR when providerType='payer' && payerId is present otherwise 1P for Provider, NM102=1 Person, lastName 1-60 alphanumeric characters")
    npi: Optional[constr(strict=True, max_length=80, min_length=0)] = Field(None, description="Loop: 2100B Segment: MN1, Element: NM109, Notes: NM108=XX Centers for Medicare and Medicaid Services National Provider Identifier 2-80 alphanumeric characters")
    service_provider_number: Optional[constr(strict=True, max_length=80, min_length=0)] = Field(None, alias="serviceProviderNumber", description="Loop: 2100B Segment: MN1, Element: NM109, Notes: NM108=SV Service Provider Number 2-80 alphanumeric characters")
    payor_id: Optional[constr(strict=True, max_length=80, min_length=0)] = Field(None, alias="payorId", description="Loop: 2100B Segment: MN1, Element: NM109, Notes: NM101=PR when providerType='payer' && payerId is present otherwise 1P for Provider, NM108=PI Payor Identification 2-80 alphanumeric characters")
    tax_id: Optional[constr(strict=True, max_length=80, min_length=0)] = Field(None, alias="taxId", description="Loop: 2100B Segment: MN1, Element: NM109, Notes: NM108=FI Federal Taxpayer's Identification Number 2-80 alphanumeric characters")
    ssn: Optional[constr(strict=True, max_length=80, min_length=0)] = Field(None, description="Loop: 2100B, Segment: NM1, Element: NM109 Notes: NM108=34 Social Security Number")
    pharmacy_processor_number: Optional[constr(strict=True, max_length=80, min_length=0)] = Field(None, alias="pharmacyProcessorNumber", description="Loop: 2100B, Segment: NM1, Element: NM109 Notes: NM108=PP Pharmacy Processor Number")
    services_plan_id: Optional[constr(strict=True, max_length=80, min_length=0)] = Field(None, alias="servicesPlanID", description="Loop: 2100B, Segment: NM1, Element: NM109 Notes: NM108=XV Centers for Medicare and Medicaid Services PlanID")
    employers_id: Optional[constr(strict=True, max_length=80, min_length=0)] = Field(None, alias="employersId", description="Loop: 2100B, Segment: NM1, Element: NM109 Notes: NM108=24 Employer's Identification Number")
    provider_code: Optional[StrictStr] = Field(None, alias="providerCode", description="Loop: 2100B Segment: PRV, Element: PRV01, Notes: PRV02=PXC Allowed descriptions are: 'AD' Admitting, 'AT' Attending, 'BI' Billing, 'CO' Consulting, 'CV' Covering, 'H' Hospital, 'HH' Home Health Care, 'LA' Laboratory, 'OT' Other Physician, 'P1' Pharmacist, 'P2' Pharmacy, 'PC' Primary Care Physician, 'PE' Performing, 'R' Rural Health Clinic, 'RF' Referring, 'SB' Submitting, 'SK' Skilled Nursing Facility, 'SU' Supervising")
    reference_identification: Optional[StrictStr] = Field(None, alias="referenceIdentification", description="Loop: 2100B Segment: PRV, Element: PRV03, Notes: PRV02=PXC referenceIdentification and controlNumber into PRV03")
    provider_type: Optional[StrictStr] = Field(None, alias="providerType", description="Loop: 2100B Segment: MN1, Element: MN101, Notes: Allowed descriptions are: 'PR' when providerType='payer' && payerId is present, '2B' when providerType='third-party administrator', '36' when providerType='employer', '80' when providerType='hospital', 'FA' when providerType='facility', 'GP' when providerType='gateway provider', 'P5' when providerType='plan sponsor', '1P' when providerType='provider'")
    additional_properties: Dict[str, Any] = {}
    __properties = ["organizationName", "firstName", "lastName", "npi", "serviceProviderNumber", "payorId", "taxId", "ssn", "pharmacyProcessorNumber", "servicesPlanID", "employersId", "providerCode", "referenceIdentification", "providerType"]

    @validator('provider_code')
    def provider_code_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('AD', 'AT', 'BI', 'CO', 'CV', 'H', 'HH', 'LA', 'OT', 'P1', 'P2', 'PC', 'PE', 'R', 'RF', 'SB', 'SK', 'SU'):
            raise ValueError("must be one of enum values ('AD', 'AT', 'BI', 'CO', 'CV', 'H', 'HH', 'LA', 'OT', 'P1', 'P2', 'PC', 'PE', 'R', 'RF', 'SB', 'SK', 'SU')")
        return value

    @validator('provider_type')
    def provider_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('payer', 'third-party administrator', 'employer', 'hospital', 'facility', 'gateway provider', 'plan sponsor', 'provider'):
            raise ValueError("must be one of enum values ('payer', 'third-party administrator', 'employer', 'hospital', 'facility', 'gateway provider', 'plan sponsor', 'provider')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Provider:
        """Create an instance of Provider from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "additional_properties"
                          },
                          exclude_none=True)
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Provider:
        """Create an instance of Provider from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Provider.parse_obj(obj)

        _obj = Provider.parse_obj({
            "organization_name": obj.get("organizationName"),
            "first_name": obj.get("firstName"),
            "last_name": obj.get("lastName"),
            "npi": obj.get("npi"),
            "service_provider_number": obj.get("serviceProviderNumber"),
            "payor_id": obj.get("payorId"),
            "tax_id": obj.get("taxId"),
            "ssn": obj.get("ssn"),
            "pharmacy_processor_number": obj.get("pharmacyProcessorNumber"),
            "services_plan_id": obj.get("servicesPlanID"),
            "employers_id": obj.get("employersId"),
            "provider_code": obj.get("providerCode"),
            "reference_identification": obj.get("referenceIdentification"),
            "provider_type": obj.get("providerType")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


