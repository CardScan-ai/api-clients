/* tslint:disable */
/* eslint-disable */
/**
 * CardScan API
 * The official documentation for the CardScan API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { ConfigurationParameters, NameCase } from '../configuration';
import { Configuration } from '../configuration';
import * as yup from 'yup';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import WebSocket from "isomorphic-ws";
import { XMLParser } from "fast-xml-parser";
import type { Stream } from "stream";
import FormData from "form-data";
import globalAxios from "axios";
import {
  CardState,
  EligibilityInfo,
  EligibilityState,
  CardWebsocketEventTypeEnum,
  KeysToSnakeCase,
  UploadParametersSnake,
  CardWebsocketEventSnake,
  CardApiResponseSnake,
  EligibilityApiResponseSnake,
  EligibilityWebsocketEventSnake,
} from "../models";
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { ApiErrorResponse } from '../models';
// @ts-ignore
import { CardApiResponse } from '../models';
// @ts-ignore
import { CardPerformance200Response } from '../models';
// @ts-ignore
import { CreateCardRequest } from '../models';
// @ts-ignore
import { CreateEligibilityRequest } from '../models';
// @ts-ignore
import { DirectUpload200Response } from '../models';
// @ts-ignore
import { DirectUploadRequest } from '../models';
// @ts-ignore
import { EligibilityApiResponse } from '../models';
// @ts-ignore
import { GenerateCardUploadUrl200Response } from '../models';
// @ts-ignore
import { GenerateCardUploadUrlRequest } from '../models';
// @ts-ignore
import { GenerateMagicLink200Response } from '../models';
// @ts-ignore
import { GetAccessToken200Response } from '../models';
// @ts-ignore
import { GetAccessToken500Response } from '../models';
// @ts-ignore
import { ListEligibility200Response } from '../models';
// @ts-ignore
import { ScanCaptureType } from '../models';
// @ts-ignore
import { ScanOrientation } from '../models';
// @ts-ignore
import { SearchCards200Response } from '../models';
// @ts-ignore
import { ValidateMagicLink200Response } from '../models';
/**
 * CardScanApi - axios parameter creator
 * @export
 */
export const CardScanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Card - Send performance data
         * @param {string} cardId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardPerformance: async (cardId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('cardPerformance', 'cardId', cardId)
            const localVarPath = `/cards/{card_id}/performance`
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new card
         * @param {CreateCardRequest} [createCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCard: async (createCardRequest?: CreateCardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Eligibility Record
         * @param {CreateEligibilityRequest} [createEligibilityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEligibility: async (createEligibilityRequest?: CreateEligibilityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eligibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEligibilityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Card
         * @param {string} cardId The ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardById: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('deleteCardById', 'cardId', cardId)
            const localVarPath = `/cards/{card_id}`
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Direct Upload
         * @param {ScanOrientation} orientation 
         * @param {ScanCaptureType} captureType 
         * @param {string} cardId 
         * @param {string | any} [stringAny] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directUpload: async (orientation: ScanOrientation, captureType: ScanCaptureType, cardId: string, stringAny?: string | any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orientation' is not null or undefined
            assertParamExists('directUpload', 'orientation', orientation)
            // verify required parameter 'captureType' is not null or undefined
            assertParamExists('directUpload', 'captureType', captureType)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('directUpload', 'cardId', cardId)
            const localVarPath = `/cards/{card_id}/upload`
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orientation !== undefined) {
                localVarQueryParameter['orientation'] = orientation;
            }

            if (captureType !== undefined) {
                localVarQueryParameter['capture_type'] = captureType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'image/jpeg';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stringAny, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Card - Generate Upload URL
         * @param {string} cardId 
         * @param {number} [expiration] 
         * @param {GenerateCardUploadUrlRequest} [generateCardUploadUrlRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCardUploadUrl: async (cardId: string, expiration?: number, generateCardUploadUrlRequest?: GenerateCardUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('generateCardUploadUrl', 'cardId', cardId)
            const localVarPath = `/cards/{card_id}/generate-upload-url`
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateCardUploadUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Magic Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMagicLink: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/generate-magic-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate an upload URL
         * @param {number} expiration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUploadUrl: async (expiration: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expiration' is not null or undefined
            assertParamExists('generateUploadUrl', 'expiration', expiration)
            const localVarPath = `/generate-upload-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Access Token
         * @param {string} [userId] The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Card by ID
         * @param {string} cardId The ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardById: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('getCardById', 'cardId', cardId)
            const localVarPath = `/cards/{card_id}`
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Eligibility
         * @param {string} eligibilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEligibilityById: async (eligibilityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eligibilityId' is not null or undefined
            assertParamExists('getEligibilityById', 'eligibilityId', eligibilityId)
            const localVarPath = `/eligibility/{eligibility_id}`
                .replace(`{${"eligibility_id"}}`, encodeURIComponent(String(eligibilityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Cards
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCards: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Eligibility
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEligibility: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eligibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Cards (200) OK
         * @param {string} query 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCards: async (query: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchCards', 'query', query)
            const localVarPath = `/cards/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Scan Metadata
         * @param {string} scanId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setScanMetadata: async (scanId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanId' is not null or undefined
            assertParamExists('setScanMetadata', 'scanId', scanId)
            const localVarPath = `/scans/{scan_id}/metadata`
                .replace(`{${"scan_id"}}`, encodeURIComponent(String(scanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Magic Link
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMagicLink: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('validateMagicLink', 'token', token)
            const localVarPath = `/validate-magic-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardScanApi - functional programming interface
 * @export
 */
export const CardScanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardScanApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Card - Send performance data
         * @param {string} cardId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cardPerformance(cardId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardPerformance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cardPerformance(cardId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.cardPerformance']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new card
         * @param {CreateCardRequest} [createCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCard(createCardRequest?: CreateCardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCard(createCardRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.createCard']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Eligibility Record
         * @param {CreateEligibilityRequest} [createEligibilityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEligibility(createEligibilityRequest?: CreateEligibilityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EligibilityApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEligibility(createEligibilityRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.createEligibility']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Card
         * @param {string} cardId The ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCardById(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCardById(cardId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.deleteCardById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Direct Upload
         * @param {ScanOrientation} orientation 
         * @param {ScanCaptureType} captureType 
         * @param {string} cardId 
         * @param {string | any} [stringAny] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directUpload(orientation: ScanOrientation, captureType: ScanCaptureType, cardId: string, stringAny?: string | any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectUpload200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directUpload(orientation, captureType, cardId, stringAny, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.directUpload']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Card - Generate Upload URL
         * @param {string} cardId 
         * @param {number} [expiration] 
         * @param {GenerateCardUploadUrlRequest} [generateCardUploadUrlRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCardUploadUrl(cardId: string, expiration?: number, generateCardUploadUrlRequest?: GenerateCardUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateCardUploadUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCardUploadUrl(cardId, expiration, generateCardUploadUrlRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.generateCardUploadUrl']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Generate Magic Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMagicLink(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateMagicLink200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMagicLink(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.generateMagicLink']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Generate an upload URL
         * @param {number} expiration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateUploadUrl(expiration: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateCardUploadUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateUploadUrl(expiration, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.generateUploadUrl']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Access Token
         * @param {string} [userId] The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessToken(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccessToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.getAccessToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Card by ID
         * @param {string} cardId The ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardById(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardById(cardId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.getCardById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Eligibility
         * @param {string} eligibilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEligibilityById(eligibilityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EligibilityApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEligibilityById(eligibilityId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.getEligibilityById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Cards
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCards(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchCards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCards(limit, cursor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.listCards']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Eligibility
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEligibility(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEligibility200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEligibility(limit, cursor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.listEligibility']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Search Cards (200) OK
         * @param {string} query 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCards(query: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchCards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCards(query, limit, cursor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.searchCards']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Set Scan Metadata
         * @param {string} scanId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setScanMetadata(scanId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setScanMetadata(scanId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.setScanMetadata']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Validate Magic Link
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateMagicLink(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateMagicLink200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateMagicLink(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CardScanApi.validateMagicLink']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CardScanApi - factory interface
 * @export
 */
export const CardScanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardScanApiFp(configuration)
    return {
        /**
         * 
         * @summary Card - Send performance data
         * @param {string} cardId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardPerformance(cardId: string, body?: object, options?: any): AxiosPromise<CardPerformance200Response> {
            return localVarFp.cardPerformance(cardId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new card
         * @param {CreateCardRequest} [createCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCard(createCardRequest?: CreateCardRequest, options?: any): AxiosPromise<CardApiResponse> {
            return localVarFp.createCard(createCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Eligibility Record
         * @param {CreateEligibilityRequest} [createEligibilityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEligibility(createEligibilityRequest?: CreateEligibilityRequest, options?: any): AxiosPromise<EligibilityApiResponse> {
            return localVarFp.createEligibility(createEligibilityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Card
         * @param {string} cardId The ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardById(cardId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCardById(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Direct Upload
         * @param {ScanOrientation} orientation 
         * @param {ScanCaptureType} captureType 
         * @param {string} cardId 
         * @param {string | any} [stringAny] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directUpload(orientation: ScanOrientation, captureType: ScanCaptureType, cardId: string, stringAny?: string | any, options?: any): AxiosPromise<DirectUpload200Response> {
            return localVarFp.directUpload(orientation, captureType, cardId, stringAny, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Card - Generate Upload URL
         * @param {string} cardId 
         * @param {number} [expiration] 
         * @param {GenerateCardUploadUrlRequest} [generateCardUploadUrlRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCardUploadUrl(cardId: string, expiration?: number, generateCardUploadUrlRequest?: GenerateCardUploadUrlRequest, options?: any): AxiosPromise<GenerateCardUploadUrl200Response> {
            return localVarFp.generateCardUploadUrl(cardId, expiration, generateCardUploadUrlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Magic Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMagicLink(options?: any): AxiosPromise<GenerateMagicLink200Response> {
            return localVarFp.generateMagicLink(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate an upload URL
         * @param {number} expiration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUploadUrl(expiration: number, options?: any): AxiosPromise<GenerateCardUploadUrl200Response> {
            return localVarFp.generateUploadUrl(expiration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Access Token
         * @param {string} [userId] The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(userId?: string, options?: any): AxiosPromise<GetAccessToken200Response> {
            return localVarFp.getAccessToken(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Card by ID
         * @param {string} cardId The ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardById(cardId: string, options?: any): AxiosPromise<CardApiResponse> {
            return localVarFp.getCardById(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Eligibility
         * @param {string} eligibilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEligibilityById(eligibilityId: string, options?: any): AxiosPromise<EligibilityApiResponse> {
            return localVarFp.getEligibilityById(eligibilityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Cards
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCards(limit?: number, cursor?: string, options?: any): AxiosPromise<SearchCards200Response> {
            return localVarFp.listCards(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Eligibility
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEligibility(limit?: number, cursor?: string, options?: any): AxiosPromise<ListEligibility200Response> {
            return localVarFp.listEligibility(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Cards (200) OK
         * @param {string} query 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCards(query: string, limit?: number, cursor?: string, options?: any): AxiosPromise<SearchCards200Response> {
            return localVarFp.searchCards(query, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Scan Metadata
         * @param {string} scanId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setScanMetadata(scanId: string, body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.setScanMetadata(scanId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate Magic Link
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateMagicLink(token: string, options?: any): AxiosPromise<ValidateMagicLink200Response> {
            return localVarFp.validateMagicLink(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardScanApi - object-oriented interface
 * @export
 * @class CardScanApi
 * @extends {BaseAPI}
 */
export class CardScanApi<TCase extends NameCase = "camel"> extends BaseAPI {
  public readonly websocket?: WebSocket;
  constructor(
    configuration?: ConfigurationParameters | { nameCase?: TCase },
    protected basePath: string = BASE_PATH,
    protected axios: AxiosInstance = globalAxios,
  ) {
    super(new Configuration(configuration), basePath, axios);
    if (this.configuration.preInitializeWebsocket) {
      const token = this.configuration.accessToken ?? this.configuration.apiKey;

      this.websocket = new WebSocket(
        `${this.configuration.websocketUrl}?token=${token}`,
      );

      this.debug("Connecting to websocket (Pre initializating)...");
    }
    this.configuration.nameCase = configuration.nameCase ?? "camel" as TCase;
  }

  /**
   * Utility method to create a websocket connection
   * @param cb This callback will be invoked with the websocket object once the connection is established or with an error if the connection fails.
   */
  public withWebsocket = (
    cb: (websocket: WebSocket | null, error: WebSocket.ErrorEvent | null) => Promise<any>,
  ) => {
    const token = this.configuration.accessToken ?? this.configuration.apiKey;

    const websocket = new WebSocket(
      `${this.configuration.websocketUrl}?token=${token}`,
    );

    this.debug("Connecting to websocket...");

    websocket.onerror = async (err) => {
      this.error(`Websocket error: ${err.message}`);
      await cb(null, err);
    };

    websocket.onopen = async () => {
      try {
        this.debug("Websocket connected. Invoking callback...");
        await cb(websocket, null);
      } catch (e) {
      } finally {
        this.debug("Websocket closing...");
        websocket.close();
      }
    };
  };

  /**
   * @summary Performs a full scan, including both front and back side scans. (This method requires a websocket URL to be set in the configuration.)
   * @param frontImage The front side image to scan. For client side code this can be a File object, for server side code this can be a Blob or a Stream.
   * @param backImage The back side image to scan. For client side code this can be a File object, for server side code this can be a Blob or a Stream.
   * */
  public async fullScan({
    frontImage,
    backImage,
  }: {
    frontImage: File | Blob | Stream;
    backImage?: File | Blob | Stream;
  }): Promise<TCase extends 'camel' ? CardApiResponse : CardApiResponseSnake> {
    this.info("Starting full scan...");

    if (!this.configuration?.websocketUrl) {
      this.error("Websocket URL not set in configuration.");
      throw new Error("This method cannot be called without a websocket URL.");
    }

    this.debug("Creating card...");
    const card = (await this.createCard(
      {
        enable_livescan: false,
        enable_backside_scan: Boolean(backImage),
      },
      {
        forceOriginalCase: true,
      },
    ));

    this.debug(`Card created successfully: ${JSON.stringify(card)}`);

    return new Promise((resolve, reject) => {
      this.withWebsocket(async (websocket, err) => {
        if (err) {
          return reject(err);
        }

        this.debug("Registering websocket card...");
        websocket.send(
          JSON.stringify({
            action: "register",
            card_id: card.card_id,
          }),
        );
        this.debug("Websocket card registered");

        this.debug("Generating front side upload URL...");
        const frontSideUploadUrlResponse = (await this.generateCardUploadUrl(
          card.card_id,
          3600,
          {
            orientation: ScanOrientation.Front,
          },
          { forceOriginalCase: true },
        ));
        this.debug(
          `Front side upload URL generated successfully, response: ${JSON.stringify(frontSideUploadUrlResponse)}}`,
        );

        const formDataFront = this.cardFormDataFactory(
          frontImage,
          frontSideUploadUrlResponse.upload_parameters as unknown as UploadParametersSnake,
        );

        try {
          this.debug("Uploading front side image...");
          await this.axios.post(
            frontSideUploadUrlResponse.upload_url,
            formDataFront,
            {
              headers: {
                "Content-Type": "multipart/form-data",
              },
            },
          );
          this.debug("Front side image uploaded successfully");
        } catch (error) {
          this.error(
            `Error uploading front side image. Error: ${error.message}`,
          );

          if (error.response && error.response.data) {
            this.debug("Parsing error response...");
            const parser = new XMLParser();
            const errorResponse = parser.parse(error.response.data);
            const cardError = this.XMLErrorToCardScanError(
              errorResponse.Error,
              error.response.status,
            );
            this.debug(
              `Error response parsed successfully. Parsed error: ${error.response.data}`,
            );
            return reject(cardError);
          } else {
            return reject(error);
          }
        }

        const frontSideRejectionStates: CardState[] = [
          CardState.FrontsideFailed,
          CardState.Error,
        ];

        this.debug("Waiting for front side processing to complete...");
        const frontSideEvent: CardWebsocketEventSnake = await new Promise(
          (resolve, reject) => {
            websocket.onmessage = (event) => {
              const data: CardWebsocketEventSnake = JSON.parse(event.data as string);
              this.debug(`Received websocket message: ${event.data}`);

              if (data.type !== CardWebsocketEventTypeEnum.Card) return;

              if (frontSideRejectionStates.includes(data.state)) {
                this.debug(
                  `Received reject state while processing frontside: ${data.state}`,
                );

                return reject(
                  new Error(`Frontside failed: ${data.error?.message}`),
                );
              }

              if (
                data.state === CardState.BacksideProcessing ||
                data.state === CardState.Completed
              ) {
                this.debug("Front side processing completed successfully");
                return resolve(data);
              }
            };
          },
        );

        if (!backImage) {
          this.info("Full scan completed successfully");

          this.debug("Fetching card details...");
          const cardDetails = (await this.getCardById(frontSideEvent.card_id, { forceOriginalCase: true }));

          if (this.configuration.nameCase === 'camel') {
            return resolve(this.toCamelCase(cardDetails));
          }

          return resolve(this.toSnakeCase(cardDetails))
        }

        this.debug("Generating back side upload URL...");
        const backSideUploadUrlResponse = (await this.generateCardUploadUrl(
          card.card_id,
          3600,
          {
            orientation: ScanOrientation.Back,
          },
          {
            forceOriginalCase: true,
          },
        ));

        const formDataBack = this.cardFormDataFactory(
          backImage,
          backSideUploadUrlResponse.upload_parameters as unknown as UploadParametersSnake,
        );

        try {
          this.debug("Uploading back side image...");
          await this.axios.post(
            backSideUploadUrlResponse.upload_url,
            formDataBack,
            {
              headers: {
                "Content-Type": "multipart/form-data",
              },
            },
          );
        } catch (error) {
          this.error(
            `Error uploading back side image. Error: ${error.message}`,
          );

          if (error.response && error.response.data) {
            this.debug("Parsing error response...");
            const parser = new XMLParser();
            const errorResponse = parser.parse(error.response.data);
            const cardError = this.XMLErrorToCardScanError(
              errorResponse.Error,
              error.response.status,
            );
            this.debug(
              `Error response parsed successfully. Parsed error: ${error.response.data}`,
            );
            return reject(cardError);
          } else {
            return reject(error);
          }
        }

        const backSideRejectionStates: CardState[] = [
          CardState.BacksideFailed,
          CardState.Error,
        ];

        this.debug("Waiting for back side processing to complete...");

        const event: CardWebsocketEventSnake = await new Promise(
          (resolve, reject) => {
            websocket.onmessage = (event) => {
              const data: CardWebsocketEventSnake = JSON.parse(event.data as string);
              this.debug(`Received websocket message: ${event.data}`);

              if (data.type !== CardWebsocketEventTypeEnum.Card) return;

              if (backSideRejectionStates.includes(data.state)) {
                this.debug(
                  `Received reject state while processing backside: ${data.state}`,
                );
                return reject(
                  new Error(`Backside failed: ${data.error?.message}`),
                );
              }

              if (data.state === CardState.Completed) {
                this.debug(`Back side processing completed successfully`);
                return resolve(data);
              }
            };
          },
        );

        this.info("Full scan completed successfully");
        this.debug("Fetching card details...");

        const cardDetails = (await this.getCardById(event.card_id, {
          forceOriginalCase: true,
        }));

        if (this.configuration.nameCase == 'camel') {
          return resolve(this.toCamelCase(cardDetails));
        }

        resolve(this.toSnakeCase(cardDetails));
      });
    });
  }
  
  private cardFormDataFactory(
    file: File | Blob | Stream,
    uploadParameters: UploadParametersSnake,
  ) {
    const formData = new FormData();

    for (const [key, value] of Object.entries(uploadParameters)) {
      formData.append(key, value);
    }

    formData.append("file", file);

    return formData;
  }

  private XMLErrorToCardScanError(
    xmlErrorObj: {
      Message: string;
      Code: string;
    },
    code: number,
  ): ApiErrorResponse {
    return {
      message: xmlErrorObj.Message,
      type: xmlErrorObj.Code,
      code,
    };
  }


  /**
   * @summary Performs an eligibility check for a card. (This method requires a websocket URL to be set in the configuration.)
   * @param cardId The ID of the card
   * @param eligibility The eligibility information to check
   * */
  public async checkEligibility(cardId: string, eligibility: EligibilityInfo): Promise<TCase extends 'camel' ? EligibilityApiResponse : EligibilityApiResponseSnake> {
    if (!this.configuration?.websocketUrl) {
      this.error("Websocket URL not set in configuration");
      throw new Error("This method cannot be called without a websocket URL.");
    }

    if (!this.validateEligibility(cardId, eligibility)) {
      throw new Error("Invalid eligibility information");
    }

    this.info(`Checking eligibility for card: ${cardId}`);

    return new Promise((resolve, reject) => {
      this.withWebsocket(async (websocket, err) => {
        if (err) {
          this.error(`Error connecting to websocket: ${err.message}`);
          return reject(err);
        }

        try {
          this.debug(`Creating eligibility for card: ${cardId}`);

          const response = (await this.createEligibility(
            {
              card_id: cardId,
              eligibility,
            },
            {
              forceOriginalCase: true,
            },
          ));

          this.debug(
            `Eligibility created successfully: ${JSON.stringify(response)}`,
          );
        } catch (e) {
          return reject(e);
        }

        this.debug("Registering card with websocket...");
        websocket.send(
          JSON.stringify({
            action: "register",
            card_id: cardId,
          }),
        );

        this.debug("Card registered with websocket");

        this.debug("Waiting for eligibility check to complete...");
        const event: EligibilityWebsocketEventSnake = await new Promise(
          (resolve, reject) => {
            websocket.onmessage = (event) => {
              const data: EligibilityWebsocketEventSnake = JSON.parse(
                event.data as string,
              );
              this.debug(`Received websocket message: ${event.data}`);

              if (data.state === EligibilityState.Completed) {
                this.debug("Received completed state");
                return resolve(data);
              }

              if (data.state === EligibilityState.Error) {
                this.debug("Received error state");
                return reject(
                  new Error(
                    `Eligibility process failed: ${data.error?.message}`,
                  ),
                );
              }
            };
          },
        );

        this.info(`Eligibility check completed successfully`);

        const elig = (await this.getEligibilityById(event.eligibility_id, {
          forceOriginalCase: true,
        }));

        if (this.configuration.nameCase === 'camel') {
          return resolve(this.toCamelCase(elig));
        }

        // Not necessary but calling toSnakeCase function makes the compiler happy :)
        resolve(this.toSnakeCase(elig));
      });
    });
  }

  /**
   * Utility method to validate eligibility information
   * @returns The validated eligibility object
   * @throws {yup.ValidationError}
   */
  public validateEligibility(cardId: string, eligibility: EligibilityInfo) {
    const npiValid = this.npiValid.bind(this);

    const schema = yup.object({
      cardId: yup.string().required().uuid(),
      eligibility: yup.object({
        provider: yup
          .object({
            firstName: yup.string().when("organizationName", {
              is: (organizationName: string) => !organizationName,
              then: (schema) =>
                schema.required(
                  "provider first name is required if organization name is not provided",
                ),
              otherwise: (schema) => schema.optional(),
            }),
            lastName: yup
              .string()
              .optional()
              .when("organizationName", {
                is: (organizationName: string) => !organizationName,
                then: (schema) =>
                  schema.required(
                    "provider last name is required if organization name is not provided",
                  ),
                otherwise: (schema) => schema.optional(),
              }),
            organizationName: yup.string().optional(),
            npi: yup
              .string()
              .required("provider npi is a required field")
              .test("isValidNpi", "npi is not valid", function (value) {
                return npiValid(value);
              }),
          })
          .required(),
        subscriber: yup
          .object({
            firstName: yup
              .string()
              .required("subscriber first name is a required field"),
            lastName: yup
              .string()
              .required("subscriber last name is a required field"),
            dateOfBirth: yup
              .string()
              .required("subscriber date of birth is a required field")
              .test(
                "isValidDate",
                "subscriber date of birth is not valid. Expected format: YYYYMMDD",
                function (value) {
                  if (value) {
                    try {
                      const date = new Date(
                        parseInt(value.substring(0, 4), 10),
                        parseInt(value.substring(4, 6), 10) - 1,
                        parseInt(value.substring(6, 8), 10),
                      );

                      const formattedDate = date
                        .toISOString()
                        .slice(0, 10)
                        .replace(/-/g, "");

                      return formattedDate === value;
                    } catch (e) {
                      return false;
                    }
                  }
                  return true;
                },
              ),
          })
          .required(),
      }),
    });

    return schema.validateSync({ cardId, eligibility }, { abortEarly: false });
  }

  private toInt(num: string) {
    return Number.parseInt(num, 10)
  }

  private sumDigits(int: number) {
    let sum = 0;
    while (int) {
      sum += int % 10;
      int = Math.floor(int / 10);
    }

    return sum;
  };

  private doubleAlternate(value: string, index?: number) {
    let pos = index ?? value.length - 1;
    let sum = 0;
    let alt = true;
    for (; pos >= 0; pos--) {
      const cur = this.toInt(value.charAt(pos));
      sum += alt ? this.sumDigits(cur * 2) : cur;
      alt = !alt;
    }

    return sum;
  };

  private npiValid(id: string, prefix = '80840') {
    const prefixRegex = /^80\d{3}$/;
    const npiRegex = /^\d{10}$/;
    const usPrefixSum = 24; // Precalculated value for 80840 (United States)
    const npi = id?.toString() ?? '';
    const pre = prefix?.toString() ?? '';

    if (!npiRegex.test(npi) || !prefixRegex.test(pre)) {
      return false;
    }

    const check = this.toInt(npi.charAt(9));
    const npiSum = this.doubleAlternate(npi, 8);
    const preSum = pre === '80840' ? usPrefixSum : this.doubleAlternate(pre, 3);
    const total = npiSum + preSum;
    const totalCeil = Math.ceil(total / 10) * 10;

    return totalCeil - total === check;
  }

    /**
     * 
     * @summary Card - Send performance data
     * @param {string} cardId 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async cardPerformance<OriginalCase extends boolean = false>(cardId: string, body?: object, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).cardPerformance(cardId, body, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Creates a new card
     * @param {CreateCardRequest} [createCardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async createCard<OriginalCase extends boolean = false>(createCardRequest?: CreateCardRequest, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).createCard(createCardRequest, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Create Eligibility Record
     * @param {CreateEligibilityRequest} [createEligibilityRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async createEligibility<OriginalCase extends boolean = false>(createEligibilityRequest?: CreateEligibilityRequest, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).createEligibility(createEligibilityRequest, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Delete Card
     * @param {string} cardId The ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async deleteCardById<OriginalCase extends boolean = false>(cardId: string, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).deleteCardById(cardId, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Direct Upload
     * @param {ScanOrientation} orientation 
     * @param {ScanCaptureType} captureType 
     * @param {string} cardId 
     * @param {string | any} [stringAny] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async directUpload<OriginalCase extends boolean = false>(orientation: ScanOrientation, captureType: ScanCaptureType, cardId: string, stringAny?: string | any, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).directUpload(orientation, captureType, cardId, stringAny, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Card - Generate Upload URL
     * @param {string} cardId 
     * @param {number} [expiration] 
     * @param {GenerateCardUploadUrlRequest} [generateCardUploadUrlRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async generateCardUploadUrl<OriginalCase extends boolean = false>(cardId: string, expiration?: number, generateCardUploadUrlRequest?: GenerateCardUploadUrlRequest, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).generateCardUploadUrl(cardId, expiration, generateCardUploadUrlRequest, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Generate Magic Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async generateMagicLink<OriginalCase extends boolean = false>(options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).generateMagicLink(options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Generate an upload URL
     * @param {number} expiration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async generateUploadUrl<OriginalCase extends boolean = false>(expiration: number, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).generateUploadUrl(expiration, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Access Token
     * @param {string} [userId] The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async getAccessToken<OriginalCase extends boolean = false>(userId?: string, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).getAccessToken(userId, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Get Card by ID
     * @param {string} cardId The ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async getCardById<OriginalCase extends boolean = false>(cardId: string, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).getCardById(cardId, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Get Eligibility
     * @param {string} eligibilityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async getEligibilityById<OriginalCase extends boolean = false>(eligibilityId: string, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).getEligibilityById(eligibilityId, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary List Cards
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async listCards<OriginalCase extends boolean = false>(limit?: number, cursor?: string, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).listCards(limit, cursor, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary List Eligibility
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async listEligibility<OriginalCase extends boolean = false>(limit?: number, cursor?: string, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).listEligibility(limit, cursor, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Search Cards (200) OK
     * @param {string} query 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async searchCards<OriginalCase extends boolean = false>(query: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).searchCards(query, limit, cursor, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Set Scan Metadata
     * @param {string} scanId 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async setScanMetadata<OriginalCase extends boolean = false>(scanId: string, body?: object, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).setScanMetadata(scanId, body, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

    /**
     * 
     * @summary Validate Magic Link
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardScanApi
     */
    public async validateMagicLink<OriginalCase extends boolean = false>(token: string, options?: RawAxiosRequestConfig & { forceOriginalCase?: OriginalCase } ) {
        let data = await CardScanApiFp(this.configuration).validateMagicLink(token, options).then((request) => request(this.axios, this.basePath)).then(r => r.data);

        if (this.configuration.nameCase === 'camel' && !options?.forceOriginalCase) {
          data = this.toCamelCase<typeof data>(data);
        }

        return data as TCase extends "snake"
          ? KeysToSnakeCase<typeof data>
          : OriginalCase extends true
          ? KeysToSnakeCase<typeof data>
          : TCase extends "camel"
          ? typeof data : never;
    }

  /**
    * Utility function to transform an object's fields to snake_case
   */
  public toSnakeCase = <T>(obj: any): T => {
    if (Array.isArray(obj)) {
      return obj.map((item) => this.toSnakeCase(item)) as unknown as T;
    } else if (obj !== null && typeof obj === "object") {
      return Object.keys(obj).reduce((acc, key) => {
        const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
        const value = obj[key];
        return {
          ...acc,
          [snakeKey]: this.toSnakeCase(value),
        };
      }, {} as any) as T;
    }
    return obj as T;
  }

  /**
   * Utility function to transform an object's fields to camelCase
   **/
  public toCamelCase = <T>(obj: any): T => {
    if (Array.isArray(obj)) {
      return obj.map((item) => this.toCamelCase(item)) as unknown as T;
    } else if (obj !== null && typeof obj === "object") {
      return Object.keys(obj).reduce((acc, key) => {
        const camelKey = key.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
        const value = obj[key];
        return {
          ...acc,
          [camelKey]: this.toCamelCase(value),
        };
      }, {} as any) as T;
    }
    return obj as T;
  };
}

