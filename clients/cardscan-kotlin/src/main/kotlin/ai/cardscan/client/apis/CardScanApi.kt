/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ai.cardscan.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import ai.cardscan.client.models.ApiErrorResponse
import ai.cardscan.client.models.CardApiResponse
import ai.cardscan.client.models.CreateCardRequest
import ai.cardscan.client.models.CreateEligibilityRequest
import ai.cardscan.client.models.DirectUpload200Response
import ai.cardscan.client.models.DirectUploadRequest
import ai.cardscan.client.models.EligibilityApiResponse
import ai.cardscan.client.models.GenerateCardUploadUrl200Response
import ai.cardscan.client.models.GenerateCardUploadUrlRequest
import ai.cardscan.client.models.GenerateMagicLink200Response
import ai.cardscan.client.models.GetAccessToken200Response
import ai.cardscan.client.models.GetAccessToken500Response
import ai.cardscan.client.models.ListEligibility200Response
import ai.cardscan.client.models.ScanCaptureType
import ai.cardscan.client.models.ScanOrientation
import ai.cardscan.client.models.SearchCards200Response
import ai.cardscan.client.models.ValidateMagicLink200Response

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import ai.cardscan.client.infrastructure.ApiClient
import ai.cardscan.client.infrastructure.ApiResponse
import ai.cardscan.client.infrastructure.ClientException
import ai.cardscan.client.infrastructure.ClientError
import ai.cardscan.client.infrastructure.ServerException
import ai.cardscan.client.infrastructure.ServerError
import ai.cardscan.client.infrastructure.MultiValueMap
import ai.cardscan.client.infrastructure.PartConfig
import ai.cardscan.client.infrastructure.RequestConfig
import ai.cardscan.client.infrastructure.RequestMethod
import ai.cardscan.client.infrastructure.ResponseType
import ai.cardscan.client.infrastructure.Success
import ai.cardscan.client.infrastructure.toMultiValue

class CardScanApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://sandbox.cardscan.ai/v1")
        }
    }

    /**
     * Creates a new card
     * 
     * @param createCardRequest  (optional)
     * @return CardApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCard(createCardRequest: CreateCardRequest? = null) : CardApiResponse {
        val localVarResponse = createCardWithHttpInfo(createCardRequest = createCardRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CardApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Creates a new card
     * 
     * @param createCardRequest  (optional)
     * @return ApiResponse<CardApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createCardWithHttpInfo(createCardRequest: CreateCardRequest?) : ApiResponse<CardApiResponse?> {
        val localVariableConfig = createCardRequestConfig(createCardRequest = createCardRequest)

        return request<CreateCardRequest, CardApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCard
     *
     * @param createCardRequest  (optional)
     * @return RequestConfig
     */
    fun createCardRequestConfig(createCardRequest: CreateCardRequest?) : RequestConfig<CreateCardRequest> {
        val localVariableBody = createCardRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cards",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Eligibility Record
     * 
     * @param createEligibilityRequest  (optional)
     * @return EligibilityApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEligibility(createEligibilityRequest: CreateEligibilityRequest? = null) : EligibilityApiResponse {
        val localVarResponse = createEligibilityWithHttpInfo(createEligibilityRequest = createEligibilityRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EligibilityApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Eligibility Record
     * 
     * @param createEligibilityRequest  (optional)
     * @return ApiResponse<EligibilityApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEligibilityWithHttpInfo(createEligibilityRequest: CreateEligibilityRequest?) : ApiResponse<EligibilityApiResponse?> {
        val localVariableConfig = createEligibilityRequestConfig(createEligibilityRequest = createEligibilityRequest)

        return request<CreateEligibilityRequest, EligibilityApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEligibility
     *
     * @param createEligibilityRequest  (optional)
     * @return RequestConfig
     */
    fun createEligibilityRequestConfig(createEligibilityRequest: CreateEligibilityRequest?) : RequestConfig<CreateEligibilityRequest> {
        val localVariableBody = createEligibilityRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/eligibility",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete Card
     * 
     * @param cardId The ID of the card
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteCardById(cardId: java.util.UUID) : Unit {
        val localVarResponse = deleteCardByIdWithHttpInfo(cardId = cardId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Card
     * 
     * @param cardId The ID of the card
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteCardByIdWithHttpInfo(cardId: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = deleteCardByIdRequestConfig(cardId = cardId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteCardById
     *
     * @param cardId The ID of the card
     * @return RequestConfig
     */
    fun deleteCardByIdRequestConfig(cardId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/cards/{card_id}".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Direct Upload
     * 
     * @param cardId 
     * @param orientation 
     * @param captureType 
     * @param directUploadRequest  (optional)
     * @return DirectUpload200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun directUpload(cardId: java.util.UUID, orientation: ScanOrientation, captureType: ScanCaptureType, directUploadRequest: DirectUploadRequest? = null) : DirectUpload200Response {
        val localVarResponse = directUploadWithHttpInfo(cardId = cardId, orientation = orientation, captureType = captureType, directUploadRequest = directUploadRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DirectUpload200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Direct Upload
     * 
     * @param cardId 
     * @param orientation 
     * @param captureType 
     * @param directUploadRequest  (optional)
     * @return ApiResponse<DirectUpload200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun directUploadWithHttpInfo(cardId: java.util.UUID, orientation: ScanOrientation, captureType: ScanCaptureType, directUploadRequest: DirectUploadRequest?) : ApiResponse<DirectUpload200Response?> {
        val localVariableConfig = directUploadRequestConfig(cardId = cardId, orientation = orientation, captureType = captureType, directUploadRequest = directUploadRequest)

        return request<DirectUploadRequest, DirectUpload200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation directUpload
     *
     * @param cardId 
     * @param orientation 
     * @param captureType 
     * @param directUploadRequest  (optional)
     * @return RequestConfig
     */
    fun directUploadRequestConfig(cardId: java.util.UUID, orientation: ScanOrientation, captureType: ScanCaptureType, directUploadRequest: DirectUploadRequest?) : RequestConfig<DirectUploadRequest> {
        val localVariableBody = directUploadRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("orientation", listOf(orientation.toString()))
                put("capture_type", listOf(captureType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cards/{card_id}/upload".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Card - Generate Upload URL
     * 
     * @param cardId 
     * @param expiration  (optional, default to 3600)
     * @param generateCardUploadUrlRequest  (optional)
     * @return GenerateCardUploadUrl200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateCardUploadUrl(cardId: java.util.UUID, expiration: kotlin.Int? = 3600, generateCardUploadUrlRequest: GenerateCardUploadUrlRequest? = null) : GenerateCardUploadUrl200Response {
        val localVarResponse = generateCardUploadUrlWithHttpInfo(cardId = cardId, expiration = expiration, generateCardUploadUrlRequest = generateCardUploadUrlRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenerateCardUploadUrl200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Card - Generate Upload URL
     * 
     * @param cardId 
     * @param expiration  (optional, default to 3600)
     * @param generateCardUploadUrlRequest  (optional)
     * @return ApiResponse<GenerateCardUploadUrl200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun generateCardUploadUrlWithHttpInfo(cardId: java.util.UUID, expiration: kotlin.Int?, generateCardUploadUrlRequest: GenerateCardUploadUrlRequest?) : ApiResponse<GenerateCardUploadUrl200Response?> {
        val localVariableConfig = generateCardUploadUrlRequestConfig(cardId = cardId, expiration = expiration, generateCardUploadUrlRequest = generateCardUploadUrlRequest)

        return request<GenerateCardUploadUrlRequest, GenerateCardUploadUrl200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation generateCardUploadUrl
     *
     * @param cardId 
     * @param expiration  (optional, default to 3600)
     * @param generateCardUploadUrlRequest  (optional)
     * @return RequestConfig
     */
    fun generateCardUploadUrlRequestConfig(cardId: java.util.UUID, expiration: kotlin.Int?, generateCardUploadUrlRequest: GenerateCardUploadUrlRequest?) : RequestConfig<GenerateCardUploadUrlRequest> {
        val localVariableBody = generateCardUploadUrlRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expiration != null) {
                    put("expiration", listOf(expiration.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cards/{card_id}/generate-upload-url".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Generate Magic Link
     * 
     * @return GenerateMagicLink200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateMagicLink() : GenerateMagicLink200Response {
        val localVarResponse = generateMagicLinkWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenerateMagicLink200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate Magic Link
     * 
     * @return ApiResponse<GenerateMagicLink200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun generateMagicLinkWithHttpInfo() : ApiResponse<GenerateMagicLink200Response?> {
        val localVariableConfig = generateMagicLinkRequestConfig()

        return request<Unit, GenerateMagicLink200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation generateMagicLink
     *
     * @return RequestConfig
     */
    fun generateMagicLinkRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/generate-magic-link",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Generate an upload URL
     * 
     * @param expiration 
     * @return GenerateCardUploadUrl200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateUploadUrl(expiration: kotlin.Int) : GenerateCardUploadUrl200Response {
        val localVarResponse = generateUploadUrlWithHttpInfo(expiration = expiration)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenerateCardUploadUrl200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate an upload URL
     * 
     * @param expiration 
     * @return ApiResponse<GenerateCardUploadUrl200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun generateUploadUrlWithHttpInfo(expiration: kotlin.Int) : ApiResponse<GenerateCardUploadUrl200Response?> {
        val localVariableConfig = generateUploadUrlRequestConfig(expiration = expiration)

        return request<Unit, GenerateCardUploadUrl200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation generateUploadUrl
     *
     * @param expiration 
     * @return RequestConfig
     */
    fun generateUploadUrlRequestConfig(expiration: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("expiration", listOf(expiration.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/generate-upload-url",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Access Token
     * 
     * @param userId The ID of the user (optional)
     * @return GetAccessToken200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccessToken(userId: kotlin.String? = null) : GetAccessToken200Response {
        val localVarResponse = getAccessTokenWithHttpInfo(userId = userId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAccessToken200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Access Token
     * 
     * @param userId The ID of the user (optional)
     * @return ApiResponse<GetAccessToken200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccessTokenWithHttpInfo(userId: kotlin.String?) : ApiResponse<GetAccessToken200Response?> {
        val localVariableConfig = getAccessTokenRequestConfig(userId = userId)

        return request<Unit, GetAccessToken200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccessToken
     *
     * @param userId The ID of the user (optional)
     * @return RequestConfig
     */
    fun getAccessTokenRequestConfig(userId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (userId != null) {
                    put("user_id", listOf(userId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/access-token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Card by ID
     * 
     * @param cardId The ID of the card
     * @return CardApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCardById(cardId: java.util.UUID) : CardApiResponse {
        val localVarResponse = getCardByIdWithHttpInfo(cardId = cardId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CardApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Card by ID
     * 
     * @param cardId The ID of the card
     * @return ApiResponse<CardApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCardByIdWithHttpInfo(cardId: java.util.UUID) : ApiResponse<CardApiResponse?> {
        val localVariableConfig = getCardByIdRequestConfig(cardId = cardId)

        return request<Unit, CardApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCardById
     *
     * @param cardId The ID of the card
     * @return RequestConfig
     */
    fun getCardByIdRequestConfig(cardId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cards/{card_id}".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Eligibility
     * 
     * @param eligibilityId 
     * @return EligibilityApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEligibilityById(eligibilityId: kotlin.String) : EligibilityApiResponse {
        val localVarResponse = getEligibilityByIdWithHttpInfo(eligibilityId = eligibilityId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EligibilityApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Eligibility
     * 
     * @param eligibilityId 
     * @return ApiResponse<EligibilityApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEligibilityByIdWithHttpInfo(eligibilityId: kotlin.String) : ApiResponse<EligibilityApiResponse?> {
        val localVariableConfig = getEligibilityByIdRequestConfig(eligibilityId = eligibilityId)

        return request<Unit, EligibilityApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEligibilityById
     *
     * @param eligibilityId 
     * @return RequestConfig
     */
    fun getEligibilityByIdRequestConfig(eligibilityId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/eligibility/{eligibility_id}".replace("{"+"eligibility_id"+"}", encodeURIComponent(eligibilityId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Scan Metadata
     * 
     * @param scanId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getScanMetadata(scanId: java.util.UUID) : Unit {
        val localVarResponse = getScanMetadataWithHttpInfo(scanId = scanId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Scan Metadata
     * 
     * @param scanId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getScanMetadataWithHttpInfo(scanId: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = getScanMetadataRequestConfig(scanId = scanId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getScanMetadata
     *
     * @param scanId 
     * @return RequestConfig
     */
    fun getScanMetadataRequestConfig(scanId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/scans/{scan_id}/metadata".replace("{"+"scan_id"+"}", encodeURIComponent(scanId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List Cards
     * 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return SearchCards200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listCards(limit: kotlin.Int? = null, cursor: kotlin.String? = null) : SearchCards200Response {
        val localVarResponse = listCardsWithHttpInfo(limit = limit, cursor = cursor)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchCards200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Cards
     * 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return ApiResponse<SearchCards200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listCardsWithHttpInfo(limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<SearchCards200Response?> {
        val localVariableConfig = listCardsRequestConfig(limit = limit, cursor = cursor)

        return request<Unit, SearchCards200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCards
     *
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return RequestConfig
     */
    fun listCardsRequestConfig(limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cards",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List Eligibility
     * 
     * @return ListEligibility200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listEligibility() : ListEligibility200Response {
        val localVarResponse = listEligibilityWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListEligibility200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Eligibility
     * 
     * @return ApiResponse<ListEligibility200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listEligibilityWithHttpInfo() : ApiResponse<ListEligibility200Response?> {
        val localVariableConfig = listEligibilityRequestConfig()

        return request<Unit, ListEligibility200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listEligibility
     *
     * @return RequestConfig
     */
    fun listEligibilityRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/eligibility",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Search Cards (200) OK
     * 
     * @param query 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return SearchCards200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchCards(query: kotlin.String, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : SearchCards200Response {
        val localVarResponse = searchCardsWithHttpInfo(query = query, limit = limit, cursor = cursor)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchCards200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search Cards (200) OK
     * 
     * @param query 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return ApiResponse<SearchCards200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchCardsWithHttpInfo(query: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<SearchCards200Response?> {
        val localVariableConfig = searchCardsRequestConfig(query = query, limit = limit, cursor = cursor)

        return request<Unit, SearchCards200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchCards
     *
     * @param query 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return RequestConfig
     */
    fun searchCardsRequestConfig(query: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("query", listOf(query.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cards/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Validate Magic Link
     * 
     * @param token 
     * @return ValidateMagicLink200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validateMagicLink(token: kotlin.String) : ValidateMagicLink200Response {
        val localVarResponse = validateMagicLinkWithHttpInfo(token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ValidateMagicLink200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Validate Magic Link
     * 
     * @param token 
     * @return ApiResponse<ValidateMagicLink200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun validateMagicLinkWithHttpInfo(token: kotlin.String) : ApiResponse<ValidateMagicLink200Response?> {
        val localVariableConfig = validateMagicLinkRequestConfig(token = token)

        return request<Unit, ValidateMagicLink200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation validateMagicLink
     *
     * @param token 
     * @return RequestConfig
     */
    fun validateMagicLinkRequestConfig(token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/validate-magic-link",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
