/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.ApiErrorResponse
import org.openapitools.client.models.CardApiResponse
import org.openapitools.client.models.CardPerformance200Response
import org.openapitools.client.models.CreateCardRequest
import org.openapitools.client.models.CreateEligibilityRequest
import org.openapitools.client.models.DirectUpload200Response
import org.openapitools.client.models.DirectUploadRequest
import org.openapitools.client.models.EligibilityApiResponse
import org.openapitools.client.models.GenerateCardUploadUrl200Response
import org.openapitools.client.models.GenerateCardUploadUrlRequest
import org.openapitools.client.models.GenerateMagicLink200Response
import org.openapitools.client.models.GetAccessToken200Response
import org.openapitools.client.models.GetAccessToken500Response
import org.openapitools.client.models.ListEligibility200Response
import org.openapitools.client.models.ScanCaptureType
import org.openapitools.client.models.ScanOrientation
import org.openapitools.client.models.SearchCards200Response
import org.openapitools.client.models.ValidateMagicLink200Response

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class CardScanApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://sandbox.cardscan.ai/v1")
        }
    }

    /**
     * Card - Send performance data
     * 
     * @param cardId 
     * @param body  (optional)
     * @return CardPerformance200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cardPerformance(cardId: java.util.UUID, body: kotlin.Any? = null) : CardPerformance200Response {
        val localVarResponse = cardPerformanceWithHttpInfo(cardId = cardId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CardPerformance200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Card - Send performance data
     * 
     * @param cardId 
     * @param body  (optional)
     * @return ApiResponse<CardPerformance200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cardPerformanceWithHttpInfo(cardId: java.util.UUID, body: kotlin.Any?) : ApiResponse<CardPerformance200Response?> {
        val localVariableConfig = cardPerformanceRequestConfig(cardId = cardId, body = body)

        return request<kotlin.Any, CardPerformance200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cardPerformance
     *
     * @param cardId 
     * @param body  (optional)
     * @return RequestConfig
     */
    fun cardPerformanceRequestConfig(cardId: java.util.UUID, body: kotlin.Any?) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cards/{card_id}/performance".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Creates a new card
     * 
     * @param createCardRequest  (optional)
     * @return CardApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCard(createCardRequest: CreateCardRequest? = null) : CardApiResponse {
        val localVarResponse = createCardWithHttpInfo(createCardRequest = createCardRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CardApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Creates a new card
     * 
     * @param createCardRequest  (optional)
     * @return ApiResponse<CardApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createCardWithHttpInfo(createCardRequest: CreateCardRequest?) : ApiResponse<CardApiResponse?> {
        val localVariableConfig = createCardRequestConfig(createCardRequest = createCardRequest)

        return request<CreateCardRequest, CardApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCard
     *
     * @param createCardRequest  (optional)
     * @return RequestConfig
     */
    fun createCardRequestConfig(createCardRequest: CreateCardRequest?) : RequestConfig<CreateCardRequest> {
        val localVariableBody = createCardRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cards",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Eligibility Record
     * 
     * @param createEligibilityRequest  (optional)
     * @return EligibilityApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEligibility(createEligibilityRequest: CreateEligibilityRequest? = null) : EligibilityApiResponse {
        val localVarResponse = createEligibilityWithHttpInfo(createEligibilityRequest = createEligibilityRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EligibilityApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Eligibility Record
     * 
     * @param createEligibilityRequest  (optional)
     * @return ApiResponse<EligibilityApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEligibilityWithHttpInfo(createEligibilityRequest: CreateEligibilityRequest?) : ApiResponse<EligibilityApiResponse?> {
        val localVariableConfig = createEligibilityRequestConfig(createEligibilityRequest = createEligibilityRequest)

        return request<CreateEligibilityRequest, EligibilityApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEligibility
     *
     * @param createEligibilityRequest  (optional)
     * @return RequestConfig
     */
    fun createEligibilityRequestConfig(createEligibilityRequest: CreateEligibilityRequest?) : RequestConfig<CreateEligibilityRequest> {
        val localVariableBody = createEligibilityRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/eligibility",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete Card
     * 
     * @param cardId The ID of the card
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteCardById(cardId: java.util.UUID) : Unit {
        val localVarResponse = deleteCardByIdWithHttpInfo(cardId = cardId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Card
     * 
     * @param cardId The ID of the card
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteCardByIdWithHttpInfo(cardId: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = deleteCardByIdRequestConfig(cardId = cardId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteCardById
     *
     * @param cardId The ID of the card
     * @return RequestConfig
     */
    fun deleteCardByIdRequestConfig(cardId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/cards/{card_id}".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Direct Upload
     * 
     * @param cardId 
     * @param orientation 
     * @param captureType 
     * @param directUploadRequest  (optional)
     * @return DirectUpload200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun directUpload(cardId: java.util.UUID, orientation: ScanOrientation, captureType: ScanCaptureType, directUploadRequest: DirectUploadRequest? = null) : DirectUpload200Response {
        val localVarResponse = directUploadWithHttpInfo(cardId = cardId, orientation = orientation, captureType = captureType, directUploadRequest = directUploadRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DirectUpload200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Direct Upload
     * 
     * @param cardId 
     * @param orientation 
     * @param captureType 
     * @param directUploadRequest  (optional)
     * @return ApiResponse<DirectUpload200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun directUploadWithHttpInfo(cardId: java.util.UUID, orientation: ScanOrientation, captureType: ScanCaptureType, directUploadRequest: DirectUploadRequest?) : ApiResponse<DirectUpload200Response?> {
        val localVariableConfig = directUploadRequestConfig(cardId = cardId, orientation = orientation, captureType = captureType, directUploadRequest = directUploadRequest)

        return request<DirectUploadRequest, DirectUpload200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation directUpload
     *
     * @param cardId 
     * @param orientation 
     * @param captureType 
     * @param directUploadRequest  (optional)
     * @return RequestConfig
     */
    fun directUploadRequestConfig(cardId: java.util.UUID, orientation: ScanOrientation, captureType: ScanCaptureType, directUploadRequest: DirectUploadRequest?) : RequestConfig<DirectUploadRequest> {
        val localVariableBody = directUploadRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("orientation", listOf(orientation.toString()))
                put("capture_type", listOf(captureType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cards/{card_id}/upload".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Card - Generate Upload URL
     * 
     * @param cardId 
     * @param expiration  (optional, default to 3600)
     * @param generateCardUploadUrlRequest  (optional)
     * @return GenerateCardUploadUrl200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateCardUploadUrl(cardId: java.util.UUID, expiration: kotlin.Int? = 3600, generateCardUploadUrlRequest: GenerateCardUploadUrlRequest? = null) : GenerateCardUploadUrl200Response {
        val localVarResponse = generateCardUploadUrlWithHttpInfo(cardId = cardId, expiration = expiration, generateCardUploadUrlRequest = generateCardUploadUrlRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenerateCardUploadUrl200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Card - Generate Upload URL
     * 
     * @param cardId 
     * @param expiration  (optional, default to 3600)
     * @param generateCardUploadUrlRequest  (optional)
     * @return ApiResponse<GenerateCardUploadUrl200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun generateCardUploadUrlWithHttpInfo(cardId: java.util.UUID, expiration: kotlin.Int?, generateCardUploadUrlRequest: GenerateCardUploadUrlRequest?) : ApiResponse<GenerateCardUploadUrl200Response?> {
        val localVariableConfig = generateCardUploadUrlRequestConfig(cardId = cardId, expiration = expiration, generateCardUploadUrlRequest = generateCardUploadUrlRequest)

        return request<GenerateCardUploadUrlRequest, GenerateCardUploadUrl200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation generateCardUploadUrl
     *
     * @param cardId 
     * @param expiration  (optional, default to 3600)
     * @param generateCardUploadUrlRequest  (optional)
     * @return RequestConfig
     */
    fun generateCardUploadUrlRequestConfig(cardId: java.util.UUID, expiration: kotlin.Int?, generateCardUploadUrlRequest: GenerateCardUploadUrlRequest?) : RequestConfig<GenerateCardUploadUrlRequest> {
        val localVariableBody = generateCardUploadUrlRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expiration != null) {
                    put("expiration", listOf(expiration.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cards/{card_id}/generate-upload-url".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Generate Magic Link
     * 
     * @return GenerateMagicLink200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateMagicLink() : GenerateMagicLink200Response {
        val localVarResponse = generateMagicLinkWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenerateMagicLink200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate Magic Link
     * 
     * @return ApiResponse<GenerateMagicLink200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun generateMagicLinkWithHttpInfo() : ApiResponse<GenerateMagicLink200Response?> {
        val localVariableConfig = generateMagicLinkRequestConfig()

        return request<Unit, GenerateMagicLink200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation generateMagicLink
     *
     * @return RequestConfig
     */
    fun generateMagicLinkRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/generate-magic-link",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Generate an upload URL
     * 
     * @param expiration 
     * @return GenerateCardUploadUrl200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateUploadUrl(expiration: kotlin.Int) : GenerateCardUploadUrl200Response {
        val localVarResponse = generateUploadUrlWithHttpInfo(expiration = expiration)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenerateCardUploadUrl200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate an upload URL
     * 
     * @param expiration 
     * @return ApiResponse<GenerateCardUploadUrl200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun generateUploadUrlWithHttpInfo(expiration: kotlin.Int) : ApiResponse<GenerateCardUploadUrl200Response?> {
        val localVariableConfig = generateUploadUrlRequestConfig(expiration = expiration)

        return request<Unit, GenerateCardUploadUrl200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation generateUploadUrl
     *
     * @param expiration 
     * @return RequestConfig
     */
    fun generateUploadUrlRequestConfig(expiration: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("expiration", listOf(expiration.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/generate-upload-url",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Access Token
     * 
     * @param userId The ID of the user (optional)
     * @return GetAccessToken200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccessToken(userId: kotlin.String? = null) : GetAccessToken200Response {
        val localVarResponse = getAccessTokenWithHttpInfo(userId = userId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAccessToken200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Access Token
     * 
     * @param userId The ID of the user (optional)
     * @return ApiResponse<GetAccessToken200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccessTokenWithHttpInfo(userId: kotlin.String?) : ApiResponse<GetAccessToken200Response?> {
        val localVariableConfig = getAccessTokenRequestConfig(userId = userId)

        return request<Unit, GetAccessToken200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccessToken
     *
     * @param userId The ID of the user (optional)
     * @return RequestConfig
     */
    fun getAccessTokenRequestConfig(userId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (userId != null) {
                    put("user_id", listOf(userId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/access-token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Card by ID
     * 
     * @param cardId The ID of the card
     * @return CardApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCardById(cardId: java.util.UUID) : CardApiResponse {
        val localVarResponse = getCardByIdWithHttpInfo(cardId = cardId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CardApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Card by ID
     * 
     * @param cardId The ID of the card
     * @return ApiResponse<CardApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCardByIdWithHttpInfo(cardId: java.util.UUID) : ApiResponse<CardApiResponse?> {
        val localVariableConfig = getCardByIdRequestConfig(cardId = cardId)

        return request<Unit, CardApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCardById
     *
     * @param cardId The ID of the card
     * @return RequestConfig
     */
    fun getCardByIdRequestConfig(cardId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cards/{card_id}".replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Eligibility
     * 
     * @param eligibilityId 
     * @return EligibilityApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEligibilityById(eligibilityId: kotlin.String) : EligibilityApiResponse {
        val localVarResponse = getEligibilityByIdWithHttpInfo(eligibilityId = eligibilityId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EligibilityApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Eligibility
     * 
     * @param eligibilityId 
     * @return ApiResponse<EligibilityApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEligibilityByIdWithHttpInfo(eligibilityId: kotlin.String) : ApiResponse<EligibilityApiResponse?> {
        val localVariableConfig = getEligibilityByIdRequestConfig(eligibilityId = eligibilityId)

        return request<Unit, EligibilityApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEligibilityById
     *
     * @param eligibilityId 
     * @return RequestConfig
     */
    fun getEligibilityByIdRequestConfig(eligibilityId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/eligibility/{eligibility_id}".replace("{"+"eligibility_id"+"}", encodeURIComponent(eligibilityId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Scan Metadata
     * 
     * @param scanId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getScanMetadata(scanId: java.util.UUID) : Unit {
        val localVarResponse = getScanMetadataWithHttpInfo(scanId = scanId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Scan Metadata
     * 
     * @param scanId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getScanMetadataWithHttpInfo(scanId: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = getScanMetadataRequestConfig(scanId = scanId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getScanMetadata
     *
     * @param scanId 
     * @return RequestConfig
     */
    fun getScanMetadataRequestConfig(scanId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/scans/{scan_id}/metadata".replace("{"+"scan_id"+"}", encodeURIComponent(scanId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List Cards
     * 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return SearchCards200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listCards(limit: kotlin.Int? = null, cursor: kotlin.String? = null) : SearchCards200Response {
        val localVarResponse = listCardsWithHttpInfo(limit = limit, cursor = cursor)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchCards200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Cards
     * 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return ApiResponse<SearchCards200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listCardsWithHttpInfo(limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<SearchCards200Response?> {
        val localVariableConfig = listCardsRequestConfig(limit = limit, cursor = cursor)

        return request<Unit, SearchCards200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCards
     *
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return RequestConfig
     */
    fun listCardsRequestConfig(limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cards",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List Eligibility
     * 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return ListEligibility200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listEligibility(limit: kotlin.Int? = null, cursor: kotlin.String? = null) : ListEligibility200Response {
        val localVarResponse = listEligibilityWithHttpInfo(limit = limit, cursor = cursor)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListEligibility200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Eligibility
     * 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return ApiResponse<ListEligibility200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listEligibilityWithHttpInfo(limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<ListEligibility200Response?> {
        val localVariableConfig = listEligibilityRequestConfig(limit = limit, cursor = cursor)

        return request<Unit, ListEligibility200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listEligibility
     *
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return RequestConfig
     */
    fun listEligibilityRequestConfig(limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/eligibility",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Search Cards (200) OK
     * 
     * @param query 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return SearchCards200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchCards(query: kotlin.String, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : SearchCards200Response {
        val localVarResponse = searchCardsWithHttpInfo(query = query, limit = limit, cursor = cursor)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchCards200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search Cards (200) OK
     * 
     * @param query 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return ApiResponse<SearchCards200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchCardsWithHttpInfo(query: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<SearchCards200Response?> {
        val localVariableConfig = searchCardsRequestConfig(query = query, limit = limit, cursor = cursor)

        return request<Unit, SearchCards200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchCards
     *
     * @param query 
     * @param limit  (optional)
     * @param cursor  (optional)
     * @return RequestConfig
     */
    fun searchCardsRequestConfig(query: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("query", listOf(query.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cards/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Validate Magic Link
     * 
     * @param token 
     * @return ValidateMagicLink200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validateMagicLink(token: kotlin.String) : ValidateMagicLink200Response {
        val localVarResponse = validateMagicLinkWithHttpInfo(token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ValidateMagicLink200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Validate Magic Link
     * 
     * @param token 
     * @return ApiResponse<ValidateMagicLink200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun validateMagicLinkWithHttpInfo(token: kotlin.String) : ApiResponse<ValidateMagicLink200Response?> {
        val localVariableConfig = validateMagicLinkRequestConfig(token = token)

        return request<Unit, ValidateMagicLink200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation validateMagicLink
     *
     * @param token 
     * @return RequestConfig
     */
    fun validateMagicLinkRequestConfig(token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/validate-magic-link",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
