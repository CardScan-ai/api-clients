/* tslint:disable */
/* eslint-disable */
/**
 * CardScan API
 * The official documentation for the CardScan API.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "../configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import * as WebSocket from "ws";
import { XMLParser } from "fast-xml-parser";
import { Stream } from "stream";
import * as FormData from "form-data";
import globalAxios from "axios";
import {
  CardState,
  CardWebsocketEvent,
  CreateCardRequestBacksideScanningEnum,
  EligibilityInfo,
  EligibilityWebsocketEvent,
  EligibilityState,
  UploadParameters,
} from "../models";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "../base";
// @ts-ignore
import { ApiErrorResponse } from "../models";
// @ts-ignore
import { CardApiResponse } from "../models";
// @ts-ignore
import { CreateCardRequest } from "../models";
// @ts-ignore
import { CreateEligibilityRequest } from "../models";
// @ts-ignore
import { DirectUpload200Response } from "../models";
// @ts-ignore
import { DirectUploadRequest } from "../models";
// @ts-ignore
import { EligibilityApiResponse } from "../models";
// @ts-ignore
import { GenerateCardUploadUrl200Response } from "../models";
// @ts-ignore
import { GenerateCardUploadUrlRequest } from "../models";
// @ts-ignore
import { GenerateMagicLink200Response } from "../models";
// @ts-ignore
import { GetAccessToken200Response } from "../models";
// @ts-ignore
import { GetAccessToken500Response } from "../models";
// @ts-ignore
import { ListEligibility200Response } from "../models";
// @ts-ignore
import { ScanCaptureType } from "../models";
// @ts-ignore
import { ScanOrientation } from "../models";
// @ts-ignore
import { SearchCards200Response } from "../models";
// @ts-ignore
import { ValidateMagicLink200Response } from "../models";
/**
 * CardScanApi - axios parameter creator
 * @export
 */
export const CardScanApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Creates a new card
     * @param {CreateCardRequest} [createCardRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCard: async (
      createCardRequest?: CreateCardRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/cards`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createCardRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create Eligibility Record
     * @param {CreateEligibilityRequest} [createEligibilityRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEligibility: async (
      createEligibilityRequest?: CreateEligibilityRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/eligibility`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEligibilityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Card
     * @param {string} cardId The ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCardById: async (
      cardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("deleteCardById", "cardId", cardId);
      const localVarPath = `/cards/{card_id}`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Direct Upload
     * @param {ScanOrientation} orientation
     * @param {ScanCaptureType} captureType
     * @param {string} cardId
     * @param {string | any} [stringAny]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    directUpload: async (
      orientation: ScanOrientation,
      captureType: ScanCaptureType,
      cardId: string,
      stringAny?: string | any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'orientation' is not null or undefined
      assertParamExists("directUpload", "orientation", orientation);
      // verify required parameter 'captureType' is not null or undefined
      assertParamExists("directUpload", "captureType", captureType);
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("directUpload", "cardId", cardId);
      const localVarPath = `/cards/{card_id}/upload`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (orientation !== undefined) {
        localVarQueryParameter["orientation"] = orientation;
      }

      if (captureType !== undefined) {
        localVarQueryParameter["capture_type"] = captureType;
      }

      localVarHeaderParameter["Content-Type"] = "image/jpeg";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        stringAny,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Card - Generate Upload URL
     * @param {string} cardId
     * @param {number} [expiration]
     * @param {GenerateCardUploadUrlRequest} [generateCardUploadUrlRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCardUploadUrl: async (
      cardId: string,
      expiration?: number,
      generateCardUploadUrlRequest?: GenerateCardUploadUrlRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("generateCardUploadUrl", "cardId", cardId);
      const localVarPath = `/cards/{card_id}/generate-upload-url`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (expiration !== undefined) {
        localVarQueryParameter["expiration"] = expiration;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        generateCardUploadUrlRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Generate Magic Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMagicLink: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/generate-magic-link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Generate an upload URL
     * @param {number} expiration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateUploadUrl: async (
      expiration: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'expiration' is not null or undefined
      assertParamExists("generateUploadUrl", "expiration", expiration);
      const localVarPath = `/generate-upload-url`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (expiration !== undefined) {
        localVarQueryParameter["expiration"] = expiration;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Access Token
     * @param {string} [userId] The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccessToken: async (
      userId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/access-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (userId !== undefined) {
        localVarQueryParameter["user_id"] = userId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Card by ID
     * @param {string} cardId The ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCardById: async (
      cardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("getCardById", "cardId", cardId);
      const localVarPath = `/cards/{card_id}`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Eligibility
     * @param {string} eligibilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEligibilityById: async (
      eligibilityId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'eligibilityId' is not null or undefined
      assertParamExists("getEligibilityById", "eligibilityId", eligibilityId);
      const localVarPath = `/eligibility/{eligibility_id}`.replace(
        `{${"eligibility_id"}}`,
        encodeURIComponent(String(eligibilityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Scan Metadata
     * @param {string} scanId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScanMetadata: async (
      scanId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'scanId' is not null or undefined
      assertParamExists("getScanMetadata", "scanId", scanId);
      const localVarPath = `/scans/{scan_id}/metadata`.replace(
        `{${"scan_id"}}`,
        encodeURIComponent(String(scanId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List Cards
     * @param {number} [limit]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCards: async (
      limit?: number,
      cursor?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/cards`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List Eligibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEligibility: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/eligibility`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search Cards (200) OK
     * @param {string} query
     * @param {number} [limit]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCards: async (
      query: string,
      limit?: number,
      cursor?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists("searchCards", "query", query);
      const localVarPath = `/cards/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Validate Magic Link
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateMagicLink: async (
      token: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists("validateMagicLink", "token", token);
      const localVarPath = `/validate-magic-link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CardScanApi - functional programming interface
 * @export
 */
export const CardScanApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CardScanApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Creates a new card
     * @param {CreateCardRequest} [createCardRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCard(
      createCardRequest?: CreateCardRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CardApiResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createCard(
        createCardRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.createCard"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Create Eligibility Record
     * @param {CreateEligibilityRequest} [createEligibilityRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEligibility(
      createEligibilityRequest?: CreateEligibilityRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EligibilityApiResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createEligibility(
          createEligibilityRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.createEligibility"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Delete Card
     * @param {string} cardId The ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCardById(
      cardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCardById(
        cardId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.deleteCardById"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Direct Upload
     * @param {ScanOrientation} orientation
     * @param {ScanCaptureType} captureType
     * @param {string} cardId
     * @param {string | any} [stringAny]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async directUpload(
      orientation: ScanOrientation,
      captureType: ScanCaptureType,
      cardId: string,
      stringAny?: string | any,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DirectUpload200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.directUpload(
        orientation,
        captureType,
        cardId,
        stringAny,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.directUpload"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Card - Generate Upload URL
     * @param {string} cardId
     * @param {number} [expiration]
     * @param {GenerateCardUploadUrlRequest} [generateCardUploadUrlRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCardUploadUrl(
      cardId: string,
      expiration?: number,
      generateCardUploadUrlRequest?: GenerateCardUploadUrlRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenerateCardUploadUrl200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateCardUploadUrl(
          cardId,
          expiration,
          generateCardUploadUrlRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.generateCardUploadUrl"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Generate Magic Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateMagicLink(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenerateMagicLink200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateMagicLink(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.generateMagicLink"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Generate an upload URL
     * @param {number} expiration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateUploadUrl(
      expiration: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GenerateCardUploadUrl200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateUploadUrl(expiration, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.generateUploadUrl"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Access Token
     * @param {string} [userId] The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccessToken(
      userId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetAccessToken200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(
        userId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.getAccessToken"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get Card by ID
     * @param {string} cardId The ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCardById(
      cardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CardApiResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCardById(
        cardId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.getCardById"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get Eligibility
     * @param {string} eligibilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEligibilityById(
      eligibilityId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EligibilityApiResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEligibilityById(
          eligibilityId,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.getEligibilityById"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get Scan Metadata
     * @param {string} scanId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScanMetadata(
      scanId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScanMetadata(
        scanId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.getScanMetadata"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary List Cards
     * @param {number} [limit]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCards(
      limit?: number,
      cursor?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SearchCards200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listCards(
        limit,
        cursor,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.listCards"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary List Eligibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEligibility(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListEligibility200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listEligibility(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.listEligibility"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Search Cards (200) OK
     * @param {string} query
     * @param {number} [limit]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchCards(
      query: string,
      limit?: number,
      cursor?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SearchCards200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchCards(
        query,
        limit,
        cursor,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.searchCards"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Validate Magic Link
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateMagicLink(
      token: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ValidateMagicLink200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateMagicLink(token, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["CardScanApi.validateMagicLink"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * CardScanApi - factory interface
 * @export
 */
export const CardScanApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CardScanApiFp(configuration);
  return {
    /**
     *
     * @summary Creates a new card
     * @param {CreateCardRequest} [createCardRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCard(
      createCardRequest?: CreateCardRequest,
      options?: any,
    ): AxiosPromise<CardApiResponse> {
      return localVarFp
        .createCard(createCardRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create Eligibility Record
     * @param {CreateEligibilityRequest} [createEligibilityRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEligibility(
      createEligibilityRequest?: CreateEligibilityRequest,
      options?: any,
    ): AxiosPromise<EligibilityApiResponse> {
      return localVarFp
        .createEligibility(createEligibilityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete Card
     * @param {string} cardId The ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCardById(cardId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteCardById(cardId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Direct Upload
     * @param {ScanOrientation} orientation
     * @param {ScanCaptureType} captureType
     * @param {string} cardId
     * @param {string | any} [stringAny]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    directUpload(
      orientation: ScanOrientation,
      captureType: ScanCaptureType,
      cardId: string,
      stringAny?: string | any,
      options?: any,
    ): AxiosPromise<DirectUpload200Response> {
      return localVarFp
        .directUpload(orientation, captureType, cardId, stringAny, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Card - Generate Upload URL
     * @param {string} cardId
     * @param {number} [expiration]
     * @param {GenerateCardUploadUrlRequest} [generateCardUploadUrlRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCardUploadUrl(
      cardId: string,
      expiration?: number,
      generateCardUploadUrlRequest?: GenerateCardUploadUrlRequest,
      options?: any,
    ): AxiosPromise<GenerateCardUploadUrl200Response> {
      return localVarFp
        .generateCardUploadUrl(
          cardId,
          expiration,
          generateCardUploadUrlRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Generate Magic Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMagicLink(
      options?: any,
    ): AxiosPromise<GenerateMagicLink200Response> {
      return localVarFp
        .generateMagicLink(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Generate an upload URL
     * @param {number} expiration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateUploadUrl(
      expiration: number,
      options?: any,
    ): AxiosPromise<GenerateCardUploadUrl200Response> {
      return localVarFp
        .generateUploadUrl(expiration, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Access Token
     * @param {string} [userId] The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccessToken(
      userId?: string,
      options?: any,
    ): AxiosPromise<GetAccessToken200Response> {
      return localVarFp
        .getAccessToken(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Card by ID
     * @param {string} cardId The ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCardById(cardId: string, options?: any): AxiosPromise<CardApiResponse> {
      return localVarFp
        .getCardById(cardId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Eligibility
     * @param {string} eligibilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEligibilityById(
      eligibilityId: string,
      options?: any,
    ): AxiosPromise<EligibilityApiResponse> {
      return localVarFp
        .getEligibilityById(eligibilityId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Scan Metadata
     * @param {string} scanId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScanMetadata(scanId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getScanMetadata(scanId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List Cards
     * @param {number} [limit]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCards(
      limit?: number,
      cursor?: string,
      options?: any,
    ): AxiosPromise<SearchCards200Response> {
      return localVarFp
        .listCards(limit, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List Eligibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEligibility(options?: any): AxiosPromise<ListEligibility200Response> {
      return localVarFp
        .listEligibility(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search Cards (200) OK
     * @param {string} query
     * @param {number} [limit]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCards(
      query: string,
      limit?: number,
      cursor?: string,
      options?: any,
    ): AxiosPromise<SearchCards200Response> {
      return localVarFp
        .searchCards(query, limit, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Validate Magic Link
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateMagicLink(
      token: string,
      options?: any,
    ): AxiosPromise<ValidateMagicLink200Response> {
      return localVarFp
        .validateMagicLink(token, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CardScanApi - object-oriented interface
 * @export
 * @class CardScanApi
 * @extends {BaseAPI}
 */
export class CardScanApi extends BaseAPI {
  private MIN_SCANS = 2;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected axios: AxiosInstance = globalAxios,
  ) {
    super(configuration, basePath, axios);
  }

  private withWebsocket = (cb: (websocket: WebSocket) => Promise<any>) => {
    const token = this.configuration.accessToken ?? this.configuration.apiKey;

    let websocketUrl = this.configuration.websocketUrl;

    if (!websocketUrl) {
      if (this.basePath.includes("sandbox")) {
        websocketUrl = "wss://sandbox-ws.cardscan.ai";
      } else {
        websocketUrl = "wss://ws.cardscan.ai";
      }
    }

    const websocket = new WebSocket(`${websocketUrl}?token=${token}`);

    websocket.onerror = (event) => {
      console.debug("WebSocket error: ", event);
      websocket.close();
      return;
    };

    websocket.onopen = async () => {
      await cb(websocket);
      websocket.close();
    };
  };

  /**
   * @summary Performs a full scan, including both front and back side scans.
   * @param frontImage The front side image to scan. For client side code this can be a File object, for server side code this can be a Blob or a Stream.
   * @param backImage The back side image to scan. For client side code this can be a File object, for server side code this can be a Blob or a Stream.
   * */
  public async fullScan({
    frontImage,
    backImage,
  }: {
    frontImage: File | Blob | Stream;
    backImage: File | Blob | Stream;
  }) {
    if (!this.configuration?.websocketUrl) {
      throw new Error("This method cannot be called without a websocket URL.");
    }

    const card = (
      await this.createCard({
        enable_livescan: false,
        enable_backside_scan: true,
      })
    ).data;

    return new Promise((resolve, reject) => {
      this.withWebsocket(async (websocket) => {
        if (websocket.readyState === WebSocket.OPEN) {
          websocket.send(
            JSON.stringify({
              action: "register",
              card_id: card.card_id,
            }),
          );
        } else {
          return reject(new Error("WebSocket is not open"));
        }

        const frontSideUploadUrlResponse = (
          await this.generateCardUploadUrl(card.card_id, 3600, {
            orientation: ScanOrientation.Front,
          })
        ).data;

        const formDataFront = this.cardFormDataFactory(
          frontImage,
          frontSideUploadUrlResponse.upload_parameters,
        );

        try {
          await this.axios.post(
            frontSideUploadUrlResponse.upload_url,
            formDataFront,
            {
              headers: {
                "Content-Type": "multipart/form-data",
              },
            },
          );
        } catch (error) {
          if (error.response && error.response.data) {
            const parser = new XMLParser();
            const errorResponse = parser.parse(error.response.data);
            const cardError = this.XMLErrorToCardScanError(
              errorResponse.Error,
              error.response.status,
            );
            return reject(cardError);
          } else {
            return reject(error);
          }
        }

        const frontSideRejectionStates: CardState[] = [
          CardState.FrontsideFailed,
          CardState.Error,
        ];

        await new Promise((resolve, reject) => {
          websocket.onmessage = (event) => {
            const data: CardWebsocketEvent = JSON.parse(event.data as string);

            if (frontSideRejectionStates.includes(data.state)) {
              return reject(
                new Error(`Frontside failed: ${data.error?.message}`),
              );
            }

            if (data.state === CardState.BacksideProcessing) {
              return resolve(data);
            }
          };
        });

        const backSideUploadUrlResponse = (
          await this.generateCardUploadUrl(card.card_id, 3600, {
            orientation: ScanOrientation.Back,
          })
        ).data;

        const formDataBack = this.cardFormDataFactory(
          backImage,
          backSideUploadUrlResponse.upload_parameters,
        );

        try {
          await this.axios.post(
            backSideUploadUrlResponse.upload_url,
            formDataBack,
            {
              headers: {
                "Content-Type": "multipart/form-data",
              },
            },
          );
        } catch (error) {
          if (error.response && error.response.data) {
            const parser = new XMLParser();
            const errorResponse = parser.parse(error.response.data);
            const cardError = this.XMLErrorToCardScanError(
              errorResponse.Error,
              error.response.status,
            );
            return reject(cardError);
          } else {
            return reject(error);
          }
        }

        const backSideRejectionStates: CardState[] = [
          CardState.BacksideFailed,
          CardState.Error,
        ];

        const event: CardWebsocketEvent = await new Promise(
          (resolve, reject) => {
            websocket.onmessage = (event) => {
              const data: CardWebsocketEvent = JSON.parse(event.data as string);

              if (backSideRejectionStates.includes(data.state)) {
                return reject(
                  new Error(`Backside failed: ${data.error?.message}`),
                );
              }

              if (data.state === CardState.Completed) {
                return resolve(data);
              }
            };
          },
        );

        resolve(event);
      });
    });
  }

  private cardFormDataFactory(
    file: File | Blob | Stream,
    uploadParameters: UploadParameters,
  ) {
    const formData = new FormData();

    for (const [key, value] of Object.entries(uploadParameters)) {
      formData.append(key, value);
    }

    formData.append("file", file);

    return formData;
  }

  private XMLErrorToCardScanError(
    xmlErrorObj: {
      Message: string;
      Code: string;
    },
    code: number,
  ): ApiErrorResponse {
    return {
      message: xmlErrorObj.Message,
      type: xmlErrorObj.Code,
      code,
    };
  }

  /**
   * @summary Performs an eligibility check for a card.
   * @param cardId The ID of the card
   * @param eligibility The eligibility information to check
   * */
  public async checkEligibility(cardId: string, eligibility: EligibilityInfo) {
    if (!this.configuration?.websocketUrl) {
      throw new Error("This method cannot be called without a websocket URL.");
    }

    return new Promise((resolve) => {
      this.withWebsocket(async (websocket) => {
        (
          await this.createEligibility({
            card_id: cardId,
            eligibility,
          })
        ).data;

        if (websocket.readyState === WebSocket.OPEN) {
          websocket.send(
            JSON.stringify({
              action: "register",
              card_id: cardId,
            }),
          );
        }

        const event: EligibilityWebsocketEvent = await new Promise(
          (resolve, reject) => {
            websocket.onmessage = (event) => {
              const data: EligibilityWebsocketEvent = JSON.parse(
                event.data as string,
              );

              if (data.state === EligibilityState.Completed) {
                return resolve(data);
              }

              if (data.state === EligibilityState.Error) {
                return reject(
                  new Error(
                    `Eligibility process failed: ${data.error?.message}`,
                  ),
                );
              }
            };
          },
        );

        resolve(event);
      });
    });
  }

  /**
   *
   * @summary Creates a new card
   * @param {CreateCardRequest} [createCardRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public createCard(
    createCardRequest?: CreateCardRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CardScanApiFp(this.configuration)
      .createCard(createCardRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create Eligibility Record
   * @param {CreateEligibilityRequest} [createEligibilityRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public createEligibility(
    createEligibilityRequest?: CreateEligibilityRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CardScanApiFp(this.configuration)
      .createEligibility(createEligibilityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete Card
   * @param {string} cardId The ID of the card
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public deleteCardById(cardId: string, options?: RawAxiosRequestConfig) {
    return CardScanApiFp(this.configuration)
      .deleteCardById(cardId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Direct Upload
   * @param {ScanOrientation} orientation
   * @param {ScanCaptureType} captureType
   * @param {string} cardId
   * @param {string | any} [stringAny]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public directUpload(
    orientation: ScanOrientation,
    captureType: ScanCaptureType,
    cardId: string,
    stringAny?: string | any,
    options?: RawAxiosRequestConfig,
  ) {
    return CardScanApiFp(this.configuration)
      .directUpload(orientation, captureType, cardId, stringAny, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Card - Generate Upload URL
   * @param {string} cardId
   * @param {number} [expiration]
   * @param {GenerateCardUploadUrlRequest} [generateCardUploadUrlRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public generateCardUploadUrl(
    cardId: string,
    expiration?: number,
    generateCardUploadUrlRequest?: GenerateCardUploadUrlRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CardScanApiFp(this.configuration)
      .generateCardUploadUrl(
        cardId,
        expiration,
        generateCardUploadUrlRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Generate Magic Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public generateMagicLink(options?: RawAxiosRequestConfig) {
    return CardScanApiFp(this.configuration)
      .generateMagicLink(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Generate an upload URL
   * @param {number} expiration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public generateUploadUrl(
    expiration: number,
    options?: RawAxiosRequestConfig,
  ) {
    return CardScanApiFp(this.configuration)
      .generateUploadUrl(expiration, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Access Token
   * @param {string} [userId] The ID of the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public getAccessToken(userId?: string, options?: RawAxiosRequestConfig) {
    return CardScanApiFp(this.configuration)
      .getAccessToken(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Card by ID
   * @param {string} cardId The ID of the card
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public getCardById(cardId: string, options?: RawAxiosRequestConfig) {
    return CardScanApiFp(this.configuration)
      .getCardById(cardId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Eligibility
   * @param {string} eligibilityId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public getEligibilityById(
    eligibilityId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return CardScanApiFp(this.configuration)
      .getEligibilityById(eligibilityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Scan Metadata
   * @param {string} scanId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public getScanMetadata(scanId: string, options?: RawAxiosRequestConfig) {
    return CardScanApiFp(this.configuration)
      .getScanMetadata(scanId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List Cards
   * @param {number} [limit]
   * @param {string} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public listCards(
    limit?: number,
    cursor?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return CardScanApiFp(this.configuration)
      .listCards(limit, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List Eligibility
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public listEligibility(options?: RawAxiosRequestConfig) {
    return CardScanApiFp(this.configuration)
      .listEligibility(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search Cards (200) OK
   * @param {string} query
   * @param {number} [limit]
   * @param {string} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public searchCards(
    query: string,
    limit?: number,
    cursor?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return CardScanApiFp(this.configuration)
      .searchCards(query, limit, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Validate Magic Link
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardScanApi
   */
  public validateMagicLink(token: string, options?: RawAxiosRequestConfig) {
    return CardScanApiFp(this.configuration)
      .validateMagicLink(token, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
